<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://seedstack.org/archives/16.7/sections/businessmanual/index.xml</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://seedstack.org/archives/16.7/sections/businessmanual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Aggregates</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/aggregates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/aggregates/</guid>
      <description>&lt;p&gt;Domain objects have a lifecycle: they are created, go through various states and eventually die (either being archived
or deleted). Many of these objects are simple, transient objects which are simply created with a call to their constructor
and thrown away after use. There is no need to complicate such objects. But some objects are more rich, with a complex
lifecycle and numerous relationships with other objects.&lt;/p&gt;

&lt;p&gt;The challenges of managing these objects can also be addressed with several patterns. The first one is the &lt;strong&gt;aggregate pattern,
which define clear ownership and boundaries between domain objects&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-is-an-aggregate&#34;&gt;What is an aggregate ?&lt;/h1&gt;

&lt;p&gt;Most business domains have very interconnected entities, sometimes up to the point where there is always a path going from
any Entity to any other. We can try to minimize the number of associations in our design, and this is a good practice
but it can lead to a translation loss between business and software. In a typical object model, it is difficult to clearly
see the boundaries of a change. This is particularly acute in systems with concurrent access such as Web applications.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is also difficult to guarantee the consistency of changes to objects in a model with complex associations and no clear
boundaries between objects. Considering every object as independent from each other is not a valid approach, but on the
other side, refreshing every object because of a change is not practical. &lt;strong&gt;A balanced solution must be found&lt;/strong&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;../img/aggregate-typologies.png&#34; alt=&#34;Aggregate typologies&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the &lt;strong&gt;aggregate pattern&lt;/strong&gt;, we want to be as close as possible to the center pattern in the figure above. The aggregate
is a cluster of associated objects that are considered as a unit for the purpose of data changes. Each Aggregate has root
and a boundary which determines what is inside the Aggregate.&lt;/p&gt;

&lt;p&gt;The Aggregate root is a specific Entity contained in the Aggregate. It is the only entry-point of the Aggregate, meaning
that it is the only Aggregate Entity that client objects can hold references to. Other objects of the Aggregate are only
accessible through the context of the Aggregate root.&lt;/p&gt;

&lt;h1 id=&#34;characteristics&#34;&gt;Characteristics&lt;/h1&gt;

&lt;p&gt;The following rules apply to Aggregates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Aggregate root has a global identity and is responsible for checking invariants within the Aggregate.&lt;/li&gt;
&lt;li&gt;Non-root Entities inside the Aggregate have a local identity that is only unique within the Aggregate.&lt;/li&gt;
&lt;li&gt;Code outside the Aggregate can only hold references to the Aggregate root. The root can hand references to internal
entities but they must only use them transiently and not hold to the reference. Value Objects can be handed without
any concern because they are immutable and side-effect free.&lt;/li&gt;
&lt;li&gt;Only Aggregate roots can be loaded directly from the persistence. All other objects must be found by traversal of
associations.&lt;/li&gt;
&lt;li&gt;Any change within the Aggregate boundary must satisfy all the Aggregate invariants.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;declaration&#34;&gt;Declaration&lt;/h1&gt;

&lt;p&gt;Creating an Aggregate with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a package with the Aggregate name,&lt;/li&gt;
&lt;li&gt;Create all the domain objects belonging to the Aggregate in this package,&lt;/li&gt;
&lt;li&gt;From all those domain objects, one Entity should be created as the &lt;strong&gt;Aggregate root&lt;/strong&gt;. This step is the focus of this
section.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To create an Aggregate root using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseAggregateRoot&lt;/code&gt; class. This class directly extends &lt;code&gt;BaseEntity&lt;/code&gt; and as such the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;
and &lt;code&gt;compareTo()&lt;/code&gt; methods will be provided out-of-the-box.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;AggregateRoot&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;compareTo()&lt;/code&gt; methods in
this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainAggregateRoot&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the two first options (base class and interface), you have to provide a generic parameter with the type of the
Aggregate root identifier.&lt;/p&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public class Order extends BaseAggregateRoot&amp;lt;Long&amp;gt; {
    private Long orderId;
    private Date checkoutDate;
    private double price;
    private List&amp;lt;OrderItem&amp;gt; items;

    Order() {
    }

    @Override
    public Long getEntityId() {
        return orderId;
    }

    public void addOrderItem(int quantity, long productId, double price) {
        OrderItem orderItem = new OrderItem();
        orderItem.setQuantity(quantity);
        orderItem.setProductId(productId);
        orderItem.setPrice(price);
        items.add(orderItem);
    }

    public void clearOrderItems() {
        items.clear();
    }

    public Long getOrderId() {
        return orderId;
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Assemblers</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/assemblers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/assemblers/</guid>
      <description>&lt;p&gt;The assembler pattern is used to transfer a representation of the state of &lt;em&gt;Aggregates&lt;/em&gt; to &lt;em&gt;DTO/Representation&lt;/em&gt; objects.
The Business Framework provides a interface and few base classes to ease the development of assemblers.&lt;/p&gt;

&lt;h1 id=&#34;default-assembler&#34;&gt;Default assembler&lt;/h1&gt;

&lt;p&gt;By default, if your mapping is obvious, you don&amp;rsquo;t have to create an explicit assembler. You just add the &lt;code&gt;@DtoOf&lt;/code&gt; annotation
on your DTO class to link them to their related Aggregate root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DtoOf(Product.class)
class ProductRepresentation {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then inject a ModelMapper-based assembler with the &lt;code&gt;@ModelMapper&lt;/code&gt; annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
@ModelMapper
Assembler&amp;lt;Product, ProductRepresentation&amp;gt; productAssembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This assembler uses the default settings of the &lt;a href=&#34;http://modelmapper.org/&#34;&gt;ModelMapper library&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-warning&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
            
                &lt;i class=&#34;fa fa-exclamation-triangle icon-2x&#34;&gt;&lt;/i&gt;
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is strongly recommended to always have a DTO. &lt;strong&gt;Never serialize domain objects to your clients.&lt;/strong&gt; Even with the default
assembler you can define a DTO that is a flat and/or partial mapping of your domain Aggregate. ModelMapper will
automatically figure out the field mapping if you respect &lt;a href=&#34;http://modelmapper.org/getting-started/#mapping&#34;&gt;their conventions&lt;/a&gt;.
Besides, you should always have integration tests that checks that the automatic mapping is correct.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;explicit-assembler&#34;&gt;Explicit assembler&lt;/h1&gt;

&lt;p&gt;Create an assembler extending &lt;code&gt;BaseAssembler&lt;/code&gt; class. It will contains
the logic of the copy between aggregate and DTO. Then, inject your
assembler in your class.&lt;/p&gt;

&lt;p&gt;There are two methods to implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;doAssembleDtoFromAggregate(dto, aggregate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doMergeAggregateWithDto(aggregate, dto)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first method creates a DTO from an aggregate root. The second
merge the mutable fields of an &lt;strong&gt;existing&lt;/strong&gt; aggregate with the data
from the dto.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Note that the aggregate identity should never be updated by the DTO.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;An assembler assembling a representation of a product.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProductAssembler extends BaseAssembler&amp;lt;Product,ProductRepresentation&amp;gt; {

    @Override
    protected void doAssembleDtoFromAggregate(ProductRepresentation targetDto, 
	         Product sourceAggregate) {
        // Flatten the id
        targetDto.setStoreId(sourceAggregate.getAggregateId().getStoreId());
        targetDto.setProductCode(sourceAggregate.getAggregateId().getProductCode());
         
        targetDto.setName(sourceAggregate.getName());
        targetDto.setDescription(sourceAggregate.getDescription());
    }
	 
    @Override
    protected void doMergeAggregateWithDto(Product targetAggregate, 
	        ProductRepresentation sourceDto) {
        // The id is not modified
        targetAggregate.setName(sourceDto.getName());
        targetAggregate.setDescription(sourceDto.getDescription());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can inject the assembler via its interface or directly via the
implementation class. Both way are acceptable, but the first way
provides a more encapsulated interface to the developer using it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
Assembler&amp;lt;Product, ProductRepresentation&amp;gt; productAssembler;

@Inject
ProductAssembler productAssembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// assemble a representation
representation = productAssembler.assembleDtoFromAggregate(product);

// merge an aggregate
Product productToMerge = catalog.retrieve(productId);
productAssembler.mergeAggregateWithDto(productToMerge, productRepresentationSource);
catalog.update(productToMerge);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;domain-specific-language&#34;&gt;Domain-Specific Language&lt;/h1&gt;

&lt;p&gt;Assembler implementations remains simple, but its usage can become
tedious when using lists or complexe worflows. To simplify this use
cases the Business Framework provides a DSL throught
&lt;code&gt;FluentAssembler&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;lists&#34;&gt;Lists&lt;/h2&gt;

&lt;p&gt;Replace common boilerplate code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;ProductRepresentation&amp;gt; representations = new ArrayList&amp;lt;&amp;gt;();
for (Product product : products {
    representations.add(productAssembler.assembleDtoFromAggregate(product))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;by oneliners:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.assemble(products).to(ProductRepresentation.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tuples&#34;&gt;Tuples&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.assemble(product, order).to(RecipeRepresentation.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;qualified-assemblers&#34;&gt;Qualified assemblers&lt;/h2&gt;

&lt;p&gt;You can specify the assembler the DSL should use by specifying a
qualifier.
For instance, the following example use the &lt;strong&gt;default ModelMapper
assembler&lt;/strong&gt;.
So in this case you don&amp;rsquo;t even have to create an assembler class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluently.assemble(products).with(AssemblerTypes.MODEL_MAPPER).to(MyDto.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;advanced-usage&#34;&gt;Advanced usage&lt;/h2&gt;

&lt;p&gt;When we merge a representation to an aggregate, the assembler expects
an existing aggregate root instance. Normally you have to retreive
this instance from a repository or to create it from a factory. This
can become a little tedious when you have to do it a lot. Or by adding
few metadata to your DTO, you can have the DSL doing it for you.&lt;/p&gt;

&lt;h3 id=&#34;get-an-aggregate-from-its-factory&#34;&gt;Get an aggregate from its factory&lt;/h3&gt;

&lt;p&gt;If the aggregate root to merge doesn&amp;rsquo;t exists, you can tell the DSL to
create it from its factory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.merge(repr).into(Product.class).fromFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will search the aggregate root&amp;rsquo;s factory
(&lt;code&gt;GenericFactory&amp;lt;Product&amp;gt;&lt;/code&gt;). Then it will search the appropriate
method to call. In order to indicate to the DSL which method should be called,
annotate the DTO&amp;rsquo;s getters matching the factory method&amp;rsquo;s parameters
with &lt;code&gt;@MatchingFactoryParameter(index=0)&lt;/code&gt;. The index represents the
position of the parameters in the factory method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProductRepesentation {

    private Short storeId;
    private Short productCode;
    private String name;
    private String description

    @MatchingFactoryParameter(index=0)
    public Short getStoreId() { ... }

    @MatchingFactoryParameter(index=1)
    public Short getProductCode() { ... }

    @MatchingFactoryParameter(index=2)
    public Short getName() { ... }

    public Short getDescription() { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public interface ProductFactory extends GenericFactory&amp;lt;Product&amp;gt; {

	Product createProduct(Short storeId, Short productCode, String name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-an-aggregate-from-its-repository&#34;&gt;Get an aggregate from its repository&lt;/h3&gt;

&lt;p&gt;If the aggregate root to merge already exists, you can tell the DSL to
get it from its repository. If the DSL doesn&amp;rsquo;t find the aggregate root
from the repository, two strategies are possible. The first throw an
exception, the second fall back to the &lt;code&gt;fromFactory()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    product = fluentAssembler.merge(representation).into(Product.class)
        .fromRepository().orFail();

} catch (AggregateNotFoundException e) {
    return Response.status(Response.Status.NOT_FOUND).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;product = fluentAssembler.merge(repr).into(Product.class)
    .fromRepository().thenFromFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will search the aggregate root&amp;rsquo;s repository
(&lt;code&gt;GenericRepository&amp;lt;Product&amp;gt;&lt;/code&gt;). Then it will call its &lt;code&gt;load()&lt;/code&gt;
method.
In order to indicate to the DSL how to find the ID,
annotate the DTO getter matching the aggregate root ID with
&lt;code&gt;@MatchingEntityId&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;If the ID is composite annotate the getter
methods matching the ID constructor parameters with
&lt;code&gt;@MatchingEntityId(index=0)&lt;/code&gt;. In this case, the index is mandatory and
represents the position of the parameters in the constructor method.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;public class ProductRepesentation {

    private Short storeId;
    private Short productCode;
    private String name;
    private String description

    @MatchingEntityId(index=0)
    public Short getStoreId() { ... }

    @MatchingEntityId(index=1)
    public Short getProductCode() { ... }

    public Short getName() { ... }

    public Short getDescription() { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ProductId extends BaseValueObject {

	private Short storeId;
	private Short productCode;

	public ProductId(Short storeId, Short productCode) {
		this.storeId = storeId;
		this.productCode = productCode;
	}

    // Getters ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;automation-with-modelmapper&#34;&gt;Automation with ModelMapper&lt;/h1&gt;

&lt;p&gt;DTOs are meant to expose domain objects or a part of these objects.
So there are often similarities between the DTOs and the domain
object.
This can lead to a lot of boilerplate code when the assembler doesn&amp;rsquo;t
hold complex logic but just populates objects.&lt;/p&gt;

&lt;p&gt;For this use case, you can now &lt;strong&gt;use a default&lt;/strong&gt; assembler based on
&lt;a href=&#34;http://modelmapper.org/&#34;&gt;ModelMapper&lt;/a&gt;. It&amp;rsquo;s an &lt;em&gt;automatic assembler&lt;/em&gt;
which provides an &lt;strong&gt;intelligent mapping&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-to-use-it&#34;&gt;How to use it ?&lt;/h2&gt;

&lt;p&gt;The only thing you have to do is to annotate the DTO with
&lt;code&gt;@DtoOf(MyAggregate.class)&lt;/code&gt;. It tells the framework to bind a default
assembler for assembling &lt;code&gt;MyAggregate&lt;/code&gt; into the annotated DTO.
After you can inject the assembler as follows, and use it as usual.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DtoOf(MyProduct.class)
public class MyDto { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Inject
@ModelMapper
private Assembler&amp;lt;MyAggregate,MyDto&amp;gt; myDtoAssemebler;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-does-it-work&#34;&gt;How does it work ?&lt;/h2&gt;

&lt;p&gt;It uses a intelligent mapping provided by the ModelMapper library.
You can find the detailed explanation here
&lt;a href=&#34;http://modelmapper.org/user-manual/how-it-works/&#34;&gt;matching documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;can-i-customize-it&#34;&gt;Can I customize it ?&lt;/h2&gt;

&lt;p&gt;Yes. If there are ambiguities, or if you only want to change the mapping of
one field, you don&amp;rsquo;t need to fall back to the old assembler. You can
just create an assembler extending the &lt;code&gt;ModelMapperAssembler&lt;/code&gt; class and
implement the methods returning a &lt;code&gt;ModelMapper&lt;/code&gt; instance.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;See here &lt;a href=&#34;http://modelmapper.org/user-manual/property-mapping/&#34;&gt;how to override the mapping&lt;/a&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;It supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deep mapping&lt;/li&gt;
&lt;li&gt;Skipping properties&lt;/li&gt;
&lt;li&gt;Providers&lt;/li&gt;
&lt;li&gt;Conditional mapping&lt;/li&gt;
&lt;li&gt;String mapping&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;can-i-see-some-code&#34;&gt;Can I see some code ?&lt;/h3&gt;

&lt;p&gt;Below is an example from the &lt;a href=&#34;https://github.com/seedstack/store-webapp-sample&#34;&gt;Web application sample&lt;/a&gt;.
The Product contains a field &lt;code&gt;entityId&lt;/code&gt; and a field &lt;code&gt;categoryId&lt;/code&gt;, but the representation only contains a field
&lt;code&gt;id&lt;/code&gt;. So ModelMapper doesn&amp;rsquo;t know which field match.&lt;/p&gt;

&lt;p&gt;To fix this, extend &lt;code&gt;ModelMapperAssembler&lt;/code&gt; and add a &lt;code&gt;PropertyMap&lt;/code&gt; to the &lt;code&gt;modelMapper&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Note that, as you implemented an assembler, you don&amp;rsquo;t use the default
assembler anymore. So remove the &lt;code&gt;@DtoOf&lt;/code&gt; annotation on the DTO.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;public class ProductModelMapperAssembler extends ModelMapperAssembler&amp;lt;Product, ProductRepresentation&amp;gt; {

    @Override
    protected void configureAssembly(ModelMapper modelMapper) {
        modelMapper.addMappings(new PropertyMap&amp;lt;Product, ProductRepresentation&amp;gt;() {
            @Override
            protected void configure() {
                // Required due to the ambiguity with the categoryId field
                map().setId(source.getEntityId());
            }
        });
    }

    @Override
    protected void configureMerge(ModelMapper modelMapper) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use it as usual.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private Assembler&amp;lt;Product, ProductRepresentation&amp;gt; assembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;assembler.assembleDtoFromAggregate(aProduct);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>Business framework basics</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/</guid>
      <description>&lt;p&gt;This manual will begin by to introducing and explaining all the concepts that you will need to know and master to build
successful business applications. These concepts come from the DDD software approach which is central to the Business
framework. You will NOT be presented with in-depth coverage of all the DDD subtleties, so to go beyond the basics you
should have a look at the &lt;a href=&#34;http://seedstack.org/archives/16.7/docs/business/bibliography/&#34;&gt;bibliography&lt;/a&gt;. Moreover, links will be provided in the text when related
quality content is available.&lt;/p&gt;

&lt;p&gt;Domain-Driven Design is &lt;strong&gt;more about a way of thinking than about code&lt;/strong&gt; but this approach has nonetheless a great
impact on the way your business will be coded. DDD does not introduce new concepts or design patterns on its own. As
a matter of fact, you will surely recognize some patterns you already know behind DDD names. It goes beyond design
patterns though, as it dictates when, where and how to use them to solve real business problems.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;As its name suggest, DDD is focused on the business and its model. This model exists independently of applications and
specific use cases and should be designed a such. Applications are clients of the model: software that will use this
model to address enterprise needs. Naturally, particular use cases and UI ideas can be used as inputs for thinking about
the model as the software is produced. But the model itself should be independent of its clients.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;big-picture&#34;&gt;Big picture&lt;/h1&gt;

&lt;p&gt;The following diagram represents the key concepts of tactical Domain-Driven Design and how they relate to each other.
This manual will describe all those patterns and how they can be implemented with SeedStack.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/all-domain.png&#34; alt=&#34;Tactical domain-driven design&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;architecture&#34;&gt;Architecture&lt;/h1&gt;

&lt;p&gt;For starters, it is important to know that DDD doesn&amp;rsquo;t require a particular architecture. Since the domain is defined
and contained inside a &lt;a href=&#39;http://seedstack.org/archives/16.7/glossary#bounded-context&#39;&gt;bounded context&lt;/a&gt;, it doesn&amp;rsquo;t influence the architecture of the whole application
or system. There are several pertinent architectural styles that you can apply to the surroundings of the domain. Some
are very broad and tend to define every aspect of the system, others are more focused and try to address a specific
demand.&lt;/p&gt;

&lt;p&gt;The business framework can itself adapt to several of these architectural styles. In this section we will present
the &lt;strong&gt;layers architecture pattern&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;layers&#34;&gt;Layers&lt;/h2&gt;

&lt;p&gt;The layers architecture pattern is commonly used in Web, enterprise and desktop applications. In this architecture
pattern, the concerns are separated into well-defined layers.&lt;/p&gt;

&lt;h3 id=&#34;traditional-definition&#34;&gt;Traditional definition&lt;/h3&gt;

&lt;p&gt;The main rule of this pattern is that each layer may couple only to itself and below. The strict layers architecture
only allows to couple to the layer directly below. We recommend to use the &lt;strong&gt;relaxed layers architecture&lt;/strong&gt; though, which
allows any higher-level layer to couple to any layer below it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/layers.png&#34; alt=&#34;DDD applied to layers architecture&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;dependency-inversion-principle&#34;&gt;Dependency Inversion Principle&lt;/h3&gt;

&lt;p&gt;In the traditional view of the layers architecture, the infrastructure is at the bottom, containing technical
mechanisms like persistence, messaging or any component dependent on third-party libraries. So every upper-layer must
couple to the infrastructure layer to use the technical facilities. It is not desirable in DDD where we want to avoid
any coupling of the domain to the infrastructure. In fact we want to avoid any coupling of any layer to the
infrastructure. To achieve this independence, we will apply the &lt;strong&gt;&lt;a href=&#39;http://seedstack.org/archives/16.7/glossary#dependency-inversion-principle&#39;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/strong&gt; which
states that:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/p&gt;

&lt;p&gt;Abstractions should not depend upon details. Details should depend upon abstractions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What does it mean in terms of code, is that a low-level component should implement interfaces defined by high components.
As such, we can move the infrastructure layer to the side.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/layers_dip.png&#34; alt=&#34;DDD applied to layers architecture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As an example of this architecture, we would have a &lt;code&gt;JpaCustomerRepository&lt;/code&gt; implementation class which would belong to
the infrastructure and which implements the &lt;code&gt;CustomerRepository&lt;/code&gt; interface defined in the domain layer. When injecting
the repository elsewhere like in services, we would only use the interface. The
&lt;a href=&#34;http://seedstack.org/archives/16.7/docs/seed/manual/#dependency-injection&#34;&gt;dependency injection mechanism&lt;/a&gt; of the Java framework would provide
the correct implementation from the infrastructure.&lt;/p&gt;

&lt;h2 id=&#34;interface-layer&#34;&gt;Interface layer&lt;/h2&gt;

&lt;p&gt;The interface layer contains the components that handle &lt;strong&gt;interactions with other systems&lt;/strong&gt;, such as Web application
views, REST resources, Web-Services, etc&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It handles the &lt;strong&gt;interpretation&lt;/strong&gt;, &lt;strong&gt;validation&lt;/strong&gt; and &lt;strong&gt;translation&lt;/strong&gt; of the inputs.&lt;/li&gt;
&lt;li&gt;It handles the &lt;strong&gt;serialization&lt;/strong&gt; of the outputs, such as DTO classes to JSON, XML, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;application-layer&#34;&gt;Application layer&lt;/h2&gt;

&lt;p&gt;The application layer is responsible for &lt;strong&gt;driving the workflow of the application&lt;/strong&gt;, executing the use cases of the system.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;These operations are independent of the interfaces by which they are exposed.&lt;/li&gt;
&lt;li&gt;This layer is well suited for &lt;strong&gt;spanning transactions&lt;/strong&gt;, high-level &lt;strong&gt;logging&lt;/strong&gt; and &lt;strong&gt;security&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;The application layer is thin in terms of domain logic, it merely &lt;strong&gt;coordinates the domain layer objects&lt;/strong&gt; to perform
the actual work through &lt;strong&gt;Application Services&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;domain-layer&#34;&gt;Domain layer&lt;/h2&gt;

&lt;p&gt;The Domain Layer is where the &lt;strong&gt;business is expressed&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The domain is independent of the use cases of the system, but is used to achieve their realization,&lt;/li&gt;
&lt;li&gt;It is a very &lt;strong&gt;behaviour-rich&lt;/strong&gt; and &lt;strong&gt;expressive&lt;/strong&gt; model of the domain, based on entities, values objects and aggregates.&lt;/li&gt;
&lt;li&gt;It contains additional blocks, such as domain services, repositories, factories, policies, etc&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;infrastructure-layer&#34;&gt;Infrastructure layer&lt;/h2&gt;

&lt;p&gt;The infrastructure layer contains the technology-specific implementations of interfaces defined in other layers.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It supports all of the three other layers in different ways, facilitating communication between the layers.&lt;/li&gt;
&lt;li&gt;It consists of everything that would still exist without the application: external libraries, database engine,
application server, messaging backend and so on.&lt;/li&gt;
&lt;li&gt;This layer can be completely replaced by another one with other technological choices without altering the system behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We often declare interfaces in &lt;strong&gt;Interfaces&lt;/strong&gt;, &lt;strong&gt;Application&lt;/strong&gt; and &lt;strong&gt;Domain&lt;/strong&gt; layers and implement them in the
infrastructure Layer. A good example is the repository: interfaces are located in the domain layer but the
implementation is in the infrastructure.&lt;/p&gt;

&lt;h1 id=&#34;supple-design&#34;&gt;Supple design&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;The ultimate purpose of software is to serve users. But first, that
same software has to serve developers. [Eric Evans]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A software is not a piece code written in a one shot sprint. It is
project that evolves. A lot of developers will have to work on it, to
refactor it or add new features. Supple design is about making it
a pleasure. It should invite to change and avoid the maintenance hell.&lt;/p&gt;

&lt;p&gt;Complex and monolithic methods make hard to refactor or reuse parts of
the code. When developers are not confident about what the software
does, they start duplicating code. When this happens, iterative
process and refactoring stops.&lt;/p&gt;

&lt;p&gt;A supple design reveals the intent of the design. Side effects should
contained and easy to predict. Behaviour should be obvious making it
easy to reason about without having to investigate the implementation.&lt;/p&gt;

&lt;p&gt;There is no one-way to achieve this suppleness but Eric Evans provides
us some clues with a set of patterns. We will try to define and
illustrate them.&lt;/p&gt;

&lt;h2 id=&#34;intention-revealing-interface&#34;&gt;Intention-Revealing Interface&lt;/h2&gt;

&lt;p&gt;This concept is all about communication between developers through
code. Names of classes and methods should describe intents instead of
means. The &lt;em&gt;ubiquitous language&lt;/em&gt; must be used to define these
names. It will improves the comprehension of the code by the other
members of the team.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a developer must consider the implementation of a component in
order to use it, the value of encapsulation is lost.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Implementation changes should not affect the expected behaviour.&lt;/p&gt;

&lt;p&gt;You can also make methods signatures clearer using meaningful Value
Objects and Entities rather than primitives and associated classes
(eg. String, long, BigDecimal, etc.). For instance, given the
following method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void setAddress(String address)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How the client developer can know what the address should look like ?
Does the model allow to change the address or is it just for
initialization purpose ? Using the concept of &lt;em&gt;Intention-Revealing
Interface&lt;/em&gt; will leads us to this newer version of the method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void changeAddress(Address address)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;side-effect-free-function&#34;&gt;Side-Effect-Free Function&lt;/h2&gt;

&lt;p&gt;We just explained how a good naming can improve the comprehension of a
model, but this is not always enougth. Complex methods usually call a
combination of other methods. When all these nested methods have
side-effects, it become hard to predict the overall behaviour.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In computer science side-effect means any modification in the state of
a system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lets say we are working on a software managing teams. We had to
implement a method allowing to merged teams. So we first wrote this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;teamOne.add(teamTwo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, it takes members of the &lt;em&gt;teamTwo&lt;/em&gt; and add them to the
&lt;em&gt;teamOne&lt;/em&gt;. It does the job. Wait ! What happens to &lt;em&gt;teamTwo&lt;/em&gt; ? Has it
been modified also ? We can&amp;rsquo;t be sure whithout looking at the code of
the &lt;em&gt;add&lt;/em&gt; method because this method is not &lt;em&gt;side-effect-free&lt;/em&gt;. After
refactoring the code, here is the second version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Team newTeam = teamOne.mergeWith(teamTwo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the newer version, &lt;em&gt;teamOne&lt;/em&gt; and &lt;em&gt;teamTwo&lt;/em&gt; are not
modified. Instead we create a new object, like that developers don&amp;rsquo;t
have to understand the implementation. The knowledge is capture in the
newly created team. The idea here is not to remove all the
side-effects otherwise the code will just allow you to perform
queries. But side-effects should be contained in small entities
methods and complex computation isoltated in value objects.&lt;/p&gt;

&lt;h2 id=&#34;assertion&#34;&gt;Assertion&lt;/h2&gt;

&lt;p&gt;In the previous section we talk about limiting side-effects. But some
of them will remains. The problem is that when they are implicit, it becomes
impossible to anticipate the changes on the state of the application
whithout following the execution path. Which breaks the
encapsulation. So in order to make them explicit use &lt;em&gt;assertions&lt;/em&gt;. It
can be done using method post-condition (for instance, with &lt;code&gt;@Valid&lt;/code&gt; from the
Validation JSR) or by using unit tests.&lt;/p&gt;

&lt;h2 id=&#34;going-further&#34;&gt;Going further&lt;/h2&gt;

&lt;p&gt;In this article, we described methods for making intentions explicit
using &lt;em&gt;Intention-Revealing Interface&lt;/em&gt;, &lt;em&gt;Side-Effect-Free Functions&lt;/em&gt;
and &lt;em&gt;Assertion&lt;/em&gt;. These methods allow us to communicate intents,
protecting encapsulation. This is very important if we want to keep
the advantages of using a &lt;em&gt;Object-oriented-language&lt;/em&gt;. It also allow
the client developer to focus on his design instead of having
understand all the inner workings of the API he uses.&lt;/p&gt;

&lt;p&gt;In his book &amp;laquo;Domain Driven Design&amp;raquo;, Eric Evans go further describing
three additional concepts: &lt;em&gt;Conceptual contour&lt;/em&gt;, &lt;em&gt;Standalone&lt;/em&gt;,
&lt;em&gt;Closure of Operations&lt;/em&gt;. I invite you to read his book if you want to
have all the tools to reach the suppleness.&lt;/p&gt;

&lt;h1 id=&#34;package-layout&#34;&gt;Package layout&lt;/h1&gt;

&lt;p&gt;We propose and recommend a well-defined package layout for organizing your business code, which is described in this
section.&lt;/p&gt;

&lt;h2 id=&#34;the-domain&#34;&gt;The domain&lt;/h2&gt;

&lt;h3 id=&#34;standalone-domain&#34;&gt;Standalone domain&lt;/h3&gt;

&lt;p&gt;If you want to build a reusable domain it must be located in its own project. It is the recommended way to build a domain
because it allows to reuse it across applications and doesn&amp;rsquo;t cost more than in-application domains. In that case, the
domain must be named and live in its own package, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.myorganization.domains.mydomain
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the domain is named &lt;code&gt;mydomain&lt;/code&gt;. Its prefix would naturally be adapted to your organization rules.&lt;/p&gt;

&lt;h3 id=&#34;in-application-domain&#34;&gt;In-application domain&lt;/h3&gt;

&lt;p&gt;If you plan to place the domain inside to your application (which is not recommended), you can just code it along
your application packages. In that case it can stay without name and live as a subpackage of your project, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.myorganization.myproject.domain
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the domain is not named, as it lives under the domain subpackage of the project. The project package would naturally
be adapted to your organization rules.&lt;/p&gt;

&lt;h3 id=&#34;package-organization&#34;&gt;Package organization&lt;/h3&gt;

&lt;p&gt;In the DDD approach, entities are grouped in sets called aggregates. Aggregates are represented as a package containing
an aggregate root and possibly additional entities. This package also contains the factory (interface and implementation),
the repository interface and the possible value objects or policies related to your aggregate.
Value objects and policies which may be used by multiple aggregates should be placed in a shared package.
Services are located in their own package.&lt;/p&gt;

&lt;p&gt;Implementations can be located in the &lt;code&gt;internal&lt;/code&gt; subpackage if they are independent of technical aspects like a third-party
library. Otherwise they must be located in the infrastructure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;org.myorganization.domains.mydomain (can also be org.myorganization.myproject.domain for in-application domain)
    - model
        - myaggregate1
            - MyAggregateRoot
            - MyEntity1
            - MyEntity2
            - MyAggregateFactory
            - MyValueObject
            - MyRepository
            - MyPolicy
            - internal
                - MyPolicyImpl
                - MyAggregateFactoryImpl
        - myaggregate2
            ...

    - services
        - MyService1
        - MyService2
        - internal
            - MyService1Impl

    - shared
        - MySharedValueObject
        - MySharedPolicy1
        - internal
            - MySharedPolicy1Impl
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-warn&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;The domain should never depends on specific technical aspects. As such no infrastructure package have a place in a reusable
domain. The infrastructure for the domain should reside in the client of the domain (the application using the domain) as
it is specific to it (a same domain can be persisted very differently in different applications).&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;the-application&#34;&gt;The application&lt;/h2&gt;

&lt;p&gt;The application layer contains application services which should be located in the application package. Implementations
can be in &lt;code&gt;internal&lt;/code&gt; subpackages if they are independent of technical aspects (third-party library). Otherwise, they must
be located in the infrastructure package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;org.myorganization.myproject
    - application
        - services
            - MyService3
            - MyService4
            - internal
                - MyService3Impl

    - infrastructure
        - services
            - 3rdparty-lib
                - MyService4Lib
        - repositories
            - jpa
                - MyRepositoryJpa
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Note that the infrastructure also contains the implementation of domain concepts related to a specific technology, such
as implementations of repositories or of some services.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;the-interfaces&#34;&gt;The interfaces&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;org.myorganization.myproject
    - rest
        - usecase1
            - UseCase1Assembler
            - UserCase1Resource
            - UseCase1Finder
            - UseCase1Representation
        - usecase2
            ...

    - infrastructure
        - finders
            - jpa
                - UseCase1FinderJpa
                - UseCase2FinderJpa
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tuples&#34;&gt;Tuples&lt;/h1&gt;

&lt;p&gt;A tuple is a data structure corresponding to a sequence of immutable
objects. It&amp;rsquo;s just like an array of objects but typed and which can&amp;rsquo;t be changed,
i.e. tuples are immutable.&lt;/p&gt;

&lt;p&gt;Tuples are commonly used to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Represent a set of data without creating temparary object
that have no real meaning.&lt;/li&gt;
&lt;li&gt;Easy access to, and manipulation of, a data set.&lt;/li&gt;
&lt;li&gt;Returning mutliple values from a method.&lt;/li&gt;
&lt;li&gt;Passing multiple values to a method through a single parameter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the Business framework, we usually see them in factories and
assemblers. As implementation for tuples we use
&lt;a href=&#34;http://javatuples.org&#34;&gt;javatuples.org&lt;/a&gt;. It provides tuple classes
from one to ten elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Unit&amp;lt;A&amp;gt; (1 element)
Pair&amp;lt;A,B&amp;gt; (2 elements)
Triplet&amp;lt;A,B,C&amp;gt; (3 elements)
Quartet&amp;lt;A,B,C,D&amp;gt; (4 elements)
Quintet&amp;lt;A,B,C,D,E&amp;gt; (5 elements)
Sextet&amp;lt;A,B,C,D,E,F&amp;gt; (6 elements)
Septet&amp;lt;A,B,C,D,E,F,G&amp;gt; (7 elements)
Octet&amp;lt;A,B,C,D,E,F,G,H&amp;gt; (8 elements)
Ennead&amp;lt;A,B,C,D,E,F,G,H,I&amp;gt; (9 elements)
Decade&amp;lt;A,B,C,D,E,F,G,H,I,J&amp;gt; (10 elements)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plus a couple of very common 2-element tuple classes equivalent to
Pair, just for the sake of code semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyValue&amp;lt;A,B&amp;gt;
LabelValue&amp;lt;A,B&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tuple classes respect the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Typesafe&lt;/li&gt;
&lt;li&gt;Immutable&lt;/li&gt;
&lt;li&gt;Iterable&lt;/li&gt;
&lt;li&gt;Serializable&lt;/li&gt;
&lt;li&gt;Comparable (implements Comparable)&lt;/li&gt;
&lt;li&gt;Implementing equals(&amp;hellip;) and hashCode()&lt;/li&gt;
&lt;li&gt;Implementing toString()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; pair = new Pair&amp;lt;Integer, String&amp;gt;(10, &amp;quot;foo&amp;quot;);
Integer value0 = pair.getValue0();
String value1 = pair.getValue1();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also provide an helper class to create tuples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; pair = Tuples.create(10, &amp;quot;foo&amp;quot;);
Tuple tuple = Tuples.create(10, &amp;quot;foo&amp;quot;, new Customer());
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;qualified-injection&#34;&gt;Qualified injection&lt;/h1&gt;

&lt;p&gt;The Business framework supports the use of qualifiers defined by the JSR 330. This feature provides the ability to
create multiple implementations for the same interface. This is useful when you have multiple algorithms or implementation
technologies for an interface.&lt;/p&gt;

&lt;h2 id=&#34;an-example-with-policies&#34;&gt;An example with policies&lt;/h2&gt;

&lt;p&gt;This pattern can be used in various situations but proves itself very useful in the case of DDD policies. To leverage it,
define a Policy interface as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Policy
public interface TaxesPolicy {

    Integer computeTaxes(Order order);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define an implementation annotated by a qualifier. The annotation &lt;code&gt;@Named&lt;/code&gt; allows to qualify an implementation with
a String.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Named(&amp;quot;FR&amp;quot;)
public class FranceTaxesPolicy implements TaxesService {

    Integer computeTaxes(Order order){
        ...
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally you can inject it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Inject @Named(&amp;quot;FR&amp;quot;)
private TaxesPolicy frenchTaxes;

@Inject @Named(&amp;quot;UK&amp;quot;)
private TaxesPolicy ukTaxes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can select it dynamically using the &lt;code&gt;&lt;a data-toggle=&#34;tooltip&#34; data-html=&#34;true&#34; title=&#39;org.&amp;amp;#8203;seedstack.&amp;amp;#8203;business.&amp;amp;#8203;domain.&amp;amp;#8203;DomainRegistry&#39; href=&#39;http://seedstack.org/javadoc/org/seedstack/business/domain/DomainRegistry.html&#39;&gt;DomainRegistry&lt;/a&gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TaxesPolicy userTaxesPolicy = domainRegistry.getPolicy(TaxesPolicy.class, userLocal);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;use-a-custom-qualifier&#34;&gt;Use a custom qualifier&lt;/h2&gt;

&lt;p&gt;If a qualifier is often used, you can create a custom qualifier annotation as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import javax.inject.Qualifier;

@Qualifier
@Target({ TYPE, METHOD, FIELD })
@Retention(RUNTIME)
public @interface France {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you use it like the &lt;code&gt;@Named&lt;/code&gt; annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Inject @France
private TaxesService taxesService;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;list-of-concepts-supporting-qualifiers&#34;&gt;List of concepts supporting qualifiers&lt;/h2&gt;

&lt;p&gt;Qualified injection can be used on these concepts out-of-the-box:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Assembler,&lt;/li&gt;
&lt;li&gt;Repository,&lt;/li&gt;
&lt;li&gt;Factory,&lt;/li&gt;
&lt;li&gt;Policy,&lt;/li&gt;
&lt;li&gt;Service,&lt;/li&gt;
&lt;li&gt;Finder.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Domain events</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/events/</guid>
      <description>&lt;p&gt;Seed Business Framework contains an API to manage domain events. The &lt;code&gt;EventService&lt;/code&gt; service is used to fire events. Events
must be immutable and extend &lt;code&gt;DomainEvent&lt;/code&gt; (which extends &lt;code&gt;BaseValueObject&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; Events can also be defined by implementing the &lt;code&gt;Event&lt;/code&gt; interface. Nevertheless, this requires to
implement &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods. Otherwise event test fixtures and call cycle detection will not work.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;For instance this event&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyEvent extends DomainEvent {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;could be fired as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventService

@Inject
private MyEventFactory eventFactory;

eventService.fire(eventFactory.createMyEvent());
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;handling-events&#34;&gt;Handling events&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;EventHandlers&lt;/strong&gt; must implement &lt;code&gt;EventHandler&lt;/code&gt; in order to receive fired events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyHandler implements EventHandler&amp;lt;MyEvent&amp;gt; {
    @Override
    public void handle(MyEvent event) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyHandler&lt;/code&gt; implements &lt;code&gt;EventHandler&amp;lt;MyEvent&amp;gt;&lt;/code&gt; which means it listens to events of &lt;code&gt;MyEvent&lt;/code&gt; type.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt; method has to be implemented to define the handler&amp;rsquo;s behaviour.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;synchronous-behavior&#34;&gt;Synchronous behavior&lt;/h2&gt;

&lt;p&gt;Events are fired synchronously and &lt;strong&gt;belong to current transaction&lt;/strong&gt;. Depending on &lt;code&gt;Exception&lt;/code&gt; management, a fired exception might rollback the transaction.&lt;/p&gt;

&lt;h2 id=&#34;event-inheritance&#34;&gt;Event inheritance&lt;/h2&gt;

&lt;p&gt;If a triggered event is assignable to &lt;code&gt;MyEvent&lt;/code&gt; (by inheritance), it will also be handled - consequently, a handler that &lt;code&gt;implements EventHandler&amp;lt;DomainEvent&amp;gt;&lt;/code&gt; will be called on any event implementing &lt;code&gt;DomainEvent&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;testing-events&#34;&gt;Testing events&lt;/h1&gt;

&lt;p&gt;The &lt;strong&gt;seed-business-core-test&lt;/strong&gt; module provides an &lt;code&gt;EventFixture&lt;/code&gt; class for integration tests on events.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was handled by an expected &lt;code&gt;EventHandler&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasHandledBy(MyHandler.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was handled by exactly a provided list of &lt;code&gt;EventHandler&lt;/code&gt;s:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasHandledExactlyBy(MyHandler.class, MyHandler2.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was not handled by an expected  &lt;code&gt;EventHandler&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasNotHandledBy(MyHandler3.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was generated from an expected &lt;code&gt;method()&lt;/code&gt; with appropriate &lt;em&gt;parameters&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
MyEvent myEvent = eventFactory.createMyEvent(SOME_EVENT_PARAM);
fixtures.given(MyService.class)
     .whenCalled(&amp;quot;doSomething&amp;quot;, SOME_METHOD_PARAM)
     .eventWasHandledBy(myEvent, MyHandler.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test if &lt;code&gt;MyHandler&lt;/code&gt; handler received &lt;code&gt;myEvent&lt;/code&gt; event when &lt;code&gt;doSomething()&lt;/code&gt; method of &lt;code&gt;MyService&lt;/code&gt; is called.&lt;/p&gt;

&lt;h1 id=&#34;provided-events&#34;&gt;Provided events&lt;/h1&gt;

&lt;h2 id=&#34;aggregate-events&#34;&gt;Aggregate events&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Seed Business Framework&lt;/strong&gt; provides following events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AggregateReadEvent&lt;/code&gt;: triggered when reading an aggregate - eg. repository &lt;code&gt;load()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AggregatePersistedEvent&lt;/code&gt;: triggered when persisting an aggregate - eg. repository &lt;code&gt;save()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AggregateDeletedEvent&lt;/code&gt;: triggered when deleting an aggregate - eg. repository &lt;code&gt;delete()&lt;/code&gt; method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Above behaviour is defined by method annotations, respectively: &lt;code&gt;@Read&lt;/code&gt;, &lt;code&gt;@Persist&lt;/code&gt; and &lt;code&gt;@Delete&lt;/code&gt;.
These annotations are only intercepted (and functional) within a repository class implementing &lt;code&gt;GenericRepository&lt;/code&gt; (read &lt;a href=&#34;#!/business-doc/hands-on-domain/repository&#34;&gt;more&lt;/a&gt; on repositories).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This mechanism is disabled by default.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To enable this feature, use following property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.seedstack.business.event]
domain.watch=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handle aggregate read events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define a custom read method:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public interface MyRepository extends GenericRepository&amp;lt;AgregateRoot, AggregateIdKey&amp;gt; {
    ...
    @Read
    AgregateRoot loadByName(String name);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;GenericRepository&lt;/code&gt; methods (load, delete, persist, save) are already annotated with appropriate annotations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;The repository reading method is called, triggering an &lt;code&gt;AggregateReadEvent&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// fire an AggregateReadEvent for the AgregateRoot
productRepository.loadByName(aggregateName);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyHandler&lt;/code&gt; handles the triggered &lt;code&gt;AggregateReadEvent&lt;/code&gt; event:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// handle an AggregateReadEvent
class MyHandler implements EventHandler&amp;lt;AggregateReadEvent&amp;gt; {
    public void handle(BaseRepositoryEvent event) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; Above handler receives all &lt;code&gt;AggregateReadEvent&lt;/code&gt; from any repository
&lt;code&gt;@Read&lt;/code&gt; annotated method. Since &lt;code&gt;AggregateReadEvent&lt;/code&gt; events contain the aggregate root
class and a context with the called method and its arguments, the handler behaviour can be defined accordingly.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Since all &amp;laquo;aggregate events&amp;raquo; extend &lt;code&gt;BaseAggregateEvent&lt;/code&gt;, it is possible to intercept them all in one handler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// handle an BaseAggregateEvent
class MyHandler implements EventHandler&amp;lt;BaseAggregateEvent&amp;gt; {
    public void handle(BaseRepositoryEvent event) {
        // if &amp;quot;event&amp;quot; depends on Product aggregate
        if (Product.class.isAssignableFrom(event.getAggregateRoot())) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;See above &lt;a href=&#34;#!/business-doc/hands-on-domain/events#handling-events&#34;&gt;handlers&lt;/a&gt; documentation for more detail about their generic behaviour.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Domain model</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/model/</guid>
      <description>&lt;p&gt;The domain model is expressed through three patterns:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Entity&lt;/strong&gt; which is an object defined primarily by its identity.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value Object&lt;/strong&gt; which is an object with no conceptual identity and solely defined by is attributes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service&lt;/strong&gt; which hold domain logic that doesn&amp;rsquo;t clearly belong to an entity nor a value object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;entities&#34;&gt;Entities&lt;/h1&gt;

&lt;p&gt;Entities are used to represent a domain concept which has an identity.&lt;/p&gt;

&lt;p&gt;Often DDD beginners have a tendency to focus more on data than on the software. This often leads in all the concepts of
the &amp;laquo;domain&amp;raquo; being coded as entities. Specially, in anemic entities using only getters and setters. Using them is not
wrong but it&amp;rsquo;s not enough to hold the insights of a domain. That&amp;rsquo;s why designing entities should be taken very carefully.&lt;/p&gt;

&lt;p&gt;The entity concept should be used for an element of your domain when you take care of its identity. An identity must be
unique and immutable. Even it an object can change during its lifetime, its identity must stay untouched. If this is not
true for your element, you should consider using a &lt;a href=&#34;#value-objects&#34;&gt;value object&lt;/a&gt; instead.&lt;/p&gt;

&lt;p&gt;When designing an entity, the critical part is to determine what is the identity and how to create it. An identity can be
hold by a set of properties. In this case, a value object can be well fitted to guaranty the identity consistency and immutability.&lt;/p&gt;

&lt;p&gt;There are different kind of creation strategies for identities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The client can pass values handling himself the uniqueness.&lt;/li&gt;
&lt;li&gt;The application can generate the identity using an algorithm.&lt;/li&gt;
&lt;li&gt;The application can rely on an external identity generator, like a database sequence.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first case is easily handled using factories. The other cases, can be usually more complicated, but the Business
framework provides an API for them (see &lt;a href=&#34;http://seedstack.org/archives/16.7/docs/business/manual/factories/#identity-generation&#34;&gt;identity generation&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;declaration&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;To create an Entity using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseEntity&lt;/code&gt; class. The &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods will be provided out-of-the-box as well as a basic  &lt;code&gt;toString()&lt;/code&gt; method. You must implement the &lt;code&gt;getEntityId()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;Entity&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;getEntityId()&lt;/code&gt;
methods in this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainEntity&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the two first options (base class and interface), you have to provide a generic parameter with the type of the
Entity identifier.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Consider the following example in which a &lt;code&gt;Customer&lt;/code&gt; Entity is identified by an e-mail of String type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Customer extends BaseEntity&amp;lt;String&amp;gt; {
    private String email;
    private Address address;

    public Customer (String email) {
        this.email = email;
    }

    @Override
    public String getEntityId() {
        return this.email;
    }

    /* Meaningful methods */
    public void changeAddress(Address newAddress) { ... }

    /* Getters */
    public Address getAddress() { ... }
    public String getEmail() { ... }
    public List&amp;lt;Order&amp;gt; getOrders() { ... }
    
    /* Try to avoid setters as they allow to alter the internal state of the entity */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;value-objects&#34;&gt;Value-Objects&lt;/h1&gt;

&lt;p&gt;An object that don&amp;rsquo;t have a conceptual identity but is just describing some characteristics of a thing is called a
Value Object. Because the most visible objects in a model are usually Entities, there is a natural tendency to assign
an identity to every domain object. But this tendency should be refrained. Here are the main characteristics of a
Value Object:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It measures, quantifies or describes a thing in the domain.&lt;/li&gt;
&lt;li&gt;It is immutable, meaning that its state cannot be changed after creation.&lt;/li&gt;
&lt;li&gt;It describes a conceptual whole. Its attributes are related to each other and are all participating to the description.
This means that all the required values should be assigned upon creation (i.e. in the constructor).&lt;/li&gt;
&lt;li&gt;It is comparable to others using value equality.&lt;/li&gt;
&lt;li&gt;Its behavior is side-effect free.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;declaration-1&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;To create a Value Object using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseValueObject&lt;/code&gt; class. In this case, the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; methods will be
provided out-of-the-box as well as a basic &lt;code&gt;toString()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;ValueObject&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; in this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainValueObject&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-1&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Cars are identified by a &amp;laquo;Vehicle Identification Number&amp;raquo; (VIN). See this &lt;a href=&#34;http://en.wikipedia.org/wiki/Vehicle_Identification_Number#Components_of_the_VIN&#34;&gt;wikipedia article&lt;/a&gt;
for the conceptual definition. To simplify our example, we will just consider the VIN as composed respectively of 3 parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3 DIGITS : World Manufacturer Identifier&lt;/li&gt;
&lt;li&gt;6 DIGITS : Vehicle descriptor section&lt;/li&gt;
&lt;li&gt;8 DIGITS : Vehicle identifier section&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a possible implementation of the VIN class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.shared.domain.after.sales.vehicle;

import org.seedstack.business.domain.BaseValueObject;

public class VIN extends BaseValueObject {
    private final String worldManufacturerIdentifier;
    private final String vehicleDescriptorSection;
    private final String vehicleIdentifierSection;

    public vehicleIdentificationNumber(
            String worldManufacturerIdentifier,
            String vehicleDescriptorSection,
            String vehicleIdentifierSection) {
        this.worldManufacturerIdentifier = worldManufacturerIdentifier;
        this.vehicleDescriptorSection = vehicleDescriptorSection;
        this.vehicleIdentifierSection = vehicleIdentifierSection;
    }

    public vehicleIdentificationNumber(String vin) {
        this.worldManufacturerIdentifier = vin.substring(0,3);
        this.vehicleDescriptorSection = vin.substring(3,9);
        this.vehicleIdentifierSection = vin.substring(9,17);
    }

    /* Getters */
    public String getWorldManufacturerIdentifier() { ... }
    public String getVehicleDescriptorSection() { ... }
    public String getVehicleIdentifierSection() { ... }

    @Override
    public String toString(){
        return worldManufacturerIdentifier + vehicleDescriptorSection
                + vehicleIdentifierSection;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;usage-as-identifiers&#34;&gt;Usage as identifiers&lt;/h2&gt;

&lt;p&gt;Value Object can also be used to represent complex identifiers for entities. For instance, you can use the VIN class defined
in the example above to identity a &lt;code&gt;Vehicle&lt;/code&gt; class. You can also add meaning and behavior to a simple value by embedding
it into a Value Object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.customer;

import javax.persistence.Embeddable;
import org.seedstack.business.domain.BaseValueObject;

public class CustomerId extends BaseValueObject {
    private String value;

    public CustomerId(String customerId) {
        this.value = customerId;
    }
    public String getValue() {
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the &lt;code&gt;CustomerId&lt;/code&gt; Value Object add meaning to the plain string. You won&amp;rsquo;t manipulate a String anymore
in your code but a CustomerId, with its own type. This type can evolve later to provide additional behavior or to
be adapt its internal structure.&lt;/p&gt;

&lt;h1 id=&#34;services&#34;&gt;Services&lt;/h1&gt;

&lt;p&gt;Services are stateless objects that implement logic which doesn&amp;rsquo;t fit in the aggregates.&lt;/p&gt;

&lt;p&gt;Services can be found in various locations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The domain, where services contain pure business logic. Naming should come from the &lt;a href=&#39;http://seedstack.org/archives/16.7/glossary#ubiquitous-language&#39;&gt;ubiquitous language&lt;/a&gt; or
be introduced into it if necessary. Parameters and return values should be domain objects. Example: a bank account transfer service.&lt;/li&gt;
&lt;li&gt;The infrastructure, where services deal with specific technological aspects. Example: a notification sending service.&lt;/li&gt;
&lt;li&gt;The application, where services contain coordination logic between other services and are more tied to a specific use-case.
These services are often the ideal place to begin and end a transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;A good service is always stateless. That doesn&amp;rsquo;t mean that a service cannot change the global state of the application
(that is, it may have side effects), but it should never hold a state of its own that could affect its behavior.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;declaration-2&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;Creating a Service with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a service interface, annotated with the &lt;code&gt;@Service&lt;/code&gt; annotation. Business Framework Services are POJOs, there is no mandated super interface.&lt;/li&gt;
&lt;li&gt;Creating a service implementation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-2&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s consider a bank account transfer, which is a service belonging to the domain.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From the domain of a &lt;em&gt;bank account management&lt;/em&gt; perspective, the transfer consists of an amount debited on an
account which is credited on another account.&lt;/li&gt;
&lt;li&gt;The inherent logic of the transfer does not belong to any of the accounts but to a service of the Domain.
It&amp;rsquo;s implementation can be rather simple or complex depending on the rules applying to the process (currency exchange
rate, transfer authorisation between countries, amount on originating account, etc&amp;hellip;).&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Service
public interface AccountTransferService {

    public AccountTransferReport transferMoney(Account toBeDebited, Account toBeCredited,
            Amount transferAmount);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Avoid services named like &amp;laquo;AccountManagement&amp;raquo; as they tend to become the place to handle all behaviour for a (sub)domain
instead of clearly specifying the intent and responsibility.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Factories</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/factories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/factories/</guid>
      <description>&lt;p&gt;A factory is a pattern used to &lt;strong&gt;create domain objects&lt;/strong&gt;, checking that provided data is complete and consistent.&lt;/p&gt;

&lt;p&gt;To be created by a factory the domain object must also implements &lt;code&gt;Producible&lt;/code&gt;. This is necessary because all
the domain objects are not producible by a factory. For instance an entity is only be producible by an aggregate
root.&lt;/p&gt;

&lt;p&gt;The types implementing &lt;code&gt;DomainObject&lt;/code&gt; and &lt;code&gt;Producible&lt;/code&gt; are the followings:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AggregateRoot,&lt;/li&gt;
&lt;li&gt;DomainPolicy,&lt;/li&gt;
&lt;li&gt;ValueObject,&lt;/li&gt;
&lt;li&gt;DomainEvent,&lt;/li&gt;
&lt;li&gt;DomainService.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;default-factory&#34;&gt;Default factory&lt;/h1&gt;

&lt;p&gt;The default factory has a single method &lt;code&gt;create&lt;/code&gt; with varargs that will match via reflection the constructor corresponding
to the passed arguments. The created domain object should implement the desired constructors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Customer extends BaseAggregate&amp;lt;Long&amp;gt; {
    private Long id;

    Customer() {
        ...
    }

    Customer(String firstName, String lastName) { // This constructor will be called
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default factory can then be injected and used by invoking its &lt;code&gt;create()&lt;/code&gt; method with arguments unambiguously corresponding
to only one constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
Factory&amp;lt;Customer&amp;gt; factory;

Customer customer = factory.create(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One benefit over the plain constructor approach is that default factories will invoke identity generation (see &lt;a href=&#34;#identity-generation&#34;&gt;below&lt;/a&gt;)
and/or validation automatically after object instantiation. The&lt;/p&gt;

&lt;p&gt;As other factories this method will provide validation on the created object. But it won&amp;rsquo;t survive to refactoring, so be careful using the method (ie. unit test it!).&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;This factory can only be used to create domain objects that implement the &lt;code&gt;Producible&lt;/code&gt; and &lt;code&gt;DomainObject&lt;/code&gt; interfaces. Classes
extending Business framework base classes will already implement those interfaces but annotated POJO, such as policies or
services, must implement them explicitly. As an alternative, you implement the &lt;code&gt;GenericDomainPolicy&lt;/code&gt; and &lt;code&gt;GenericDomainService&lt;/code&gt;
interfaces instead.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;custom-factory&#34;&gt;Custom factory&lt;/h1&gt;

&lt;p&gt;A custom factory is composed of an interface, which is located in the package of the aggregate it constructs, and an
implementation which can be located either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the aggregate package too,&lt;/li&gt;
&lt;li&gt;Or in an infrastructure package if it is dependent upon a specific technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The factory interface has to extend the &lt;code&gt;GenericFactory&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.order;

import org.javatuples.Triplet;
import org.seedstack.business.domain.GenericFactory;

public interface OrderFactory extends GenericFactory&amp;lt;Order&amp;gt; {

    Order createOrder(String customerId, Date checkoutDate, Double price,
            List&amp;lt;Triplet&amp;lt;Integer, Double, Long&amp;gt;&amp;gt; orderItemTriplets);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Order&lt;/code&gt; is the type which is the expected to be returned by all the create methods.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createOrder&lt;/code&gt; method creates an &lt;code&gt;Order&lt;/code&gt; aggregate with the required parameters. Some parameters can be grouped with a tuple like
&lt;code&gt;oderItemTriplets&lt;/code&gt; which represents a list &lt;code&gt;OrderItem&lt;/code&gt; entities belonging to the &lt;code&gt;Order&lt;/code&gt; aggregate (see
&lt;a href=&#34;http://seedstack.org/archives/16.7/docs/business/manual/#tuples&#34;&gt;tuples&lt;/a&gt; for more information on tuple pattern).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The factory implementation must extend the &lt;code&gt;BaseFactory&lt;/code&gt; abstract class and implement its own interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.order;

import org.javatuples.Triplet;
import org.seedstack.business.domain.BaseFactory;
import org.mycompany.myapp.domain.customer.CustomerId;

public class OrderFactoryImpl extends BaseFactory&amp;lt;Order&amp;gt; implements OrderFactory {

    @Override
    public Order createOrder(String customerId) {
        Order o = new Order();

        o.setCustomerId(new CustomerId(customerId));
        o.setCheckoutDate(new Date());

        return o;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the factory encapsulates the logic of creating a minimal but valid &lt;code&gt;Order&lt;/code&gt; aggregate. This order can be further
populated by an assembler or by custom logic.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;When the implementation and its interface share the same package, the &lt;strong&gt;implementation should be in package visibility&lt;/strong&gt;.
It prevents any direct use of the implementation.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;identity-generation&#34;&gt;Identity generation&lt;/h1&gt;

&lt;p&gt;Factories provide methods to create entities with a well defined identity. But sometimes, you want to delegate the identity
creation, for instance to an Oracle sequence. For this use case Seed provides an &lt;strong&gt;identity generation strategies&lt;/strong&gt;.
A generation strategy makes sure a unique identity is provided to any new Entity before it is even persisted.&lt;/p&gt;

&lt;h2 id=&#34;declaration&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;Below is an aggregate using the identity strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.myaggregate;

public class MyAggregate extends BaseAggregateRoot&amp;lt;UUID&amp;gt; {

    @Identity(handler = UUIDHandler.class)
    private UUID id;

    private String name;
    private MyEntity mySubEntity;
    private Set&amp;lt;MyEntity&amp;gt; mySubEntities;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is an Entity using the identity strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.myaggregate;

public class MyEntity extends BaseEntity&amp;lt;Long&amp;gt; {

    @Identity(handler = SequenceHandler.class)
    private Long id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;@Identity&lt;/code&gt; annotation is applied on attribute holding the object identity. This annotation takes two arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;: strategy implementation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source&lt;/code&gt;: a String that can be used in a custom handler. For instance, it could provide a SEQUENCE name for DB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only specifying the identity strategy is not enough to effectively generate an identity. An implementation of the strategy
must be configured:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp.domain.model.myaggregate.MyAggregate]
identity.handler-qualifier = simple-UUID

[org.mycompany.myapp.domain.model.myaggregate.MyEntity]
identity.handler-qualifier = oracle-sequence
identity.sequence-name = SEQ_TEST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case we can see that the &lt;code&gt;simple-UUID&lt;/code&gt; implementation will be used for &lt;code&gt;MyAggregate&lt;/code&gt;. Similarly, the &lt;code&gt;oracle-sequence&lt;/code&gt;
implementation will be used for &lt;code&gt;MyEntity&lt;/code&gt; but is further configured with a sequence name.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;The chosen identity strategy is applied:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Automatically, on methods annotated with the &lt;code&gt;@Create&lt;/code&gt; annotation. They are intercepted to apply the identity strategy
on their return value.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class MyAggregateFactoryDefault extends BaseFactory&amp;lt;MyAggregate&amp;gt;
        implements MyAggregateFactory {

    @Create
    @Override
    public MyAggregate createMyAggregate(String name) {
        MyAggregate myAggregate = new MyAggregate();
        myAggregate.setName(name);

        MyEntity myEntity = createMyEntity();
        myAggregate.setMyEntity(myEntity);

        return myAggregate;
    }

    @Create
    MyEntity createMyEntity() {
        return new MyEntity();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Manually, by injecting the &lt;code&gt;IdentityService&lt;/code&gt; service and invoking its &lt;code&gt;identify()&lt;/code&gt; method with the entity to generate
an identity for as argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class MyAggregateFactoryDefault extends BaseFactory&amp;lt;MyAggregate&amp;gt;
        implements MyAggregateFactory {

    @Inject
    IdentityService identityService;

    @Override
    public MyAggregate createMyAggregate(String name) {
        MyAggregate myAggregate = new MyAggregate();
        identityService.identify(myAggregate);
        myAggregate.setName(name);

        MyEntity myEntity = new MyEntity();
        identityService.identify(myEntity);
        myAggregate.setMyEntity(myEntity);

        return myAggregate;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that identity generation doesn&amp;rsquo;t walk the object graph to generate identities for eventual sub-entities. You must
trigger identity generation (automatically or manually) separately on each entity.&lt;/p&gt;

&lt;div class=&#34;callout callout-tips&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
                &lt;i class=&#34;fa fa-lightbulb-o icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;If all methods of a factory delegate identity generation to Seed, a &lt;code&gt;@Create&lt;/code&gt; annotation can be applied directly at the
class or interface level.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;custom-identity-handler&#34;&gt;Custom identity handler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;img/manage-entity-spi.svg&#34; alt=&#34;identity-seed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Two different options are available to define custom identity handlers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/manage-entity-usage.png&#34; alt=&#34;identity-seed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Below is an example of a basic Timestamp id generation strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.infrastructure.domain;

import org.seedstack.business.domain.BaseEntity;
import org.seedstack.business.domain.identity.IdentityHandler;

@Named(&amp;quot;timestamp-id&amp;quot;)
public class TimestampIdentityHandler implements IdentityHandler&amp;lt;BaseEntity&amp;lt;Long&amp;gt;, Long&amp;gt; {

    @Override
    public Long handle(BaseEntity&amp;lt;Long&amp;gt; entity, Map&amp;lt;String, String&amp;gt; entityConfig) {
        return new Date().getTime();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;provided-identity-strategies&#34;&gt;Provided identity strategies&lt;/h2&gt;

&lt;h3 id=&#34;sequencehandler&#34;&gt;SequenceHandler&lt;/h3&gt;

&lt;p&gt;Handles sequence generated ID. Two implementations are provided:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OracleSequenceHandler&lt;/code&gt;: Get next oracle sequence value for new entity id. The following properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = oracle-sequence
identity.sequence-name = your_sequence_name
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InMemorySequenceHandler&lt;/code&gt;: To be used &lt;strong&gt;ONLY&lt;/strong&gt; for testing (preserves behaviour without a database). The following
properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = inmemory-sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uuidhandler&#34;&gt;UUIDHandler&lt;/h3&gt;

&lt;p&gt;Use for handling UUID generated ID. One implementation is provided:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SimpleUUIDHandler&lt;/code&gt;: Get new random UUID from java.util.UUID.randomUUID(). Need one property using entity props
configuration:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = simple-UUID
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Finders</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/finders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/finders/</guid>
      <description>&lt;p&gt;The role of a finder is to query the persistence layer or any data source to obtain objects specific to an interface of
the application. It only does &lt;strong&gt;read-only&lt;/strong&gt; operations and is NOT meant to replace the repository as it doesn&amp;rsquo;t produce
domain objects but interface-specific objects like REST representations.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;A finder shouldn&amp;rsquo;t generally delegate its data retrieval to the domain repository. Instead it should directly issue the most efficient query against the persistence layer and construct DTO objects, completely bypassing the domain. Consider the following implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You should write as many finders as required by your application interfaces.&lt;/li&gt;
&lt;li&gt;You can query a model completely different from your domain model and optimized for reading purposes (i.e. a read model) or not model at all.&lt;/li&gt;
&lt;li&gt;You can rely on a completely different technology than the domain persistence, like an high-performance index.&lt;/li&gt;
&lt;/ul&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;callout callout-tips&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
                &lt;i class=&#34;fa fa-lightbulb-o icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Don&amp;rsquo;t create finders needlessly: if your data retrieval needs are simple enough to not require a finder, just use the domain repositories directly in your interface and transform the retrieved domain objects to DTO with assemblers.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Creating a Finder with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a finder interface,&lt;/li&gt;
&lt;li&gt;Creating a finder implementation, located in the infrastructure as it depends upon a persistence technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Business Framework Finders are POJOs, there is no mandated interface. Just annotate your finder interface with the
&lt;code&gt;@Finder&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h1 id=&#34;interface&#34;&gt;Interface&lt;/h1&gt;

&lt;p&gt;Create the interface for your finder. A finder is annotated with &lt;code&gt;@Finder&lt;/code&gt; and is declared as read only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Finder
public interface CustomerFinder {

    List&amp;lt;CustomerRepresentation&amp;gt; findAllCustomers();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;p&gt;In the infrastructure layer, provide the implementation (here with JPA):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CustomerJpaFinder implements CustomerFinder {

    @Inject
    private FluentAssembler assembler;

    @Override
    public List&amp;lt;CustomerRepresentation&amp;gt; findAllCustomer() {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&amp;lt;Customer&amp;gt; q = cb.createQuery(Customer.class);
        q.select(q.from(Customer.class));

        return fluentAssembler
                   .assemble(entityManager.createQuery(q).getResultList())
                   .to(CustomerRepresentation.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Pagination</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/pagination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/pagination/</guid>
      <description>&lt;p&gt;The data presentation API helps developers presenting the data from their domain to external actors. Those are
generally remote REST clients like a browser, web services consumers or RPC/RMI clients. The data presentation API supports
patterns often used in data restitution: pagination, infinite-scroll, random chunk access.&lt;/p&gt;

&lt;h1 id=&#34;concepts&#34;&gt;Concepts&lt;/h1&gt;

&lt;p&gt;The following describes the API. We&amp;rsquo;ll specialize some concepts already presented like the finder.
We focus the creation of this API on solving the problem of returning portion result out of very big one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://seedstack.org/archives/16.7/puml/business/business-api-interfaces-finder.png&#34; alt=&#34;domain aggregates&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;Range&lt;/strong&gt; is just a class that represents an &lt;strong&gt;offset&lt;/strong&gt; and a &lt;strong&gt;size&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;Result&lt;/strong&gt; symbolises a canonical representation of the ranged return of a request made from a persistence. It holds:

&lt;ul&gt;
&lt;li&gt;the list that contains the result itself,&lt;/li&gt;
&lt;li&gt;the actual list size,&lt;/li&gt;
&lt;li&gt;the full size of the whole request.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;View&lt;/strong&gt; represents a viewpoint of an already existing list. Its focus is the restitution of a portion of the given
list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RangeFinder&amp;lt;Item,Criteria&amp;gt;&lt;/code&gt; is a High level interfaces for finder that sum up the following assertion: Given a
&lt;strong&gt;Range&lt;/strong&gt; and a &lt;strong&gt;Criteria&lt;/strong&gt; please find the &lt;strong&gt;Result&lt;/strong&gt; for the Item type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
Notice that &lt;strong&gt;Criteria&lt;/strong&gt; here, is not a type, but a generic to be substituted when subclassing. For
instance a &lt;code&gt;Map&amp;lt;String, Object&amp;gt;&lt;/code&gt; or a custom class.
&lt;/div&gt;

&lt;p&gt;In order to &lt;strong&gt;move out the complex computation (page, chunk, ..) away from the RangeFinder&lt;/strong&gt; we only provide him a
Range. Its first and only objective is to fetch data from persistence according to a given criteria. View management is
completely orthogonal to the restitution a given list from a criteria.&lt;/p&gt;

&lt;p&gt;The actual &lt;em&gt;Range&lt;/em&gt; can be greater than the needed portion. This way, the result can be reused according that the Criteria
and the result size has not changed.&lt;/p&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;Create a finder by extending the &lt;code&gt;BaseRangeFinder&lt;/code&gt; class. This abstract class needs you to implement two methods.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;computeResultList()&lt;/code&gt; method which should return the list of matching entity with the expected range.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;computeFullRequestSize()&lt;/code&gt; method should return the size of complete list matching the criteria.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For instance create the following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Finder
 public interface Dto1Finder extends RangeFinder&amp;lt;Dto1, Map&amp;lt;String, Object&amp;gt;&amp;gt; {

     PaginatedView&amp;lt;ProductRepresentation&amp;gt; findItemByQuery(Page page, String searchQuery);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implement it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JpaUnit(&amp;quot;my-unit&amp;quot;)
@Transactional
public class Dto1SimpleJpaFinder extends BaseRangeFinder&amp;lt;Dto1, String&amp;gt;
    implements Dto1Finder {

    @Inject
    private EntityManager entityManager;

    @Override
    public PaginatedView&amp;lt;ProductRepresentation&amp;gt; findItemByQuery(Page page, String query) {
        Range range = Range.rangeFromPageInfo(page.getIndex(), page.getCapacity());
        Result&amp;lt;Dto1&amp;gt; result = find(range, query);
        return new PaginatedView&amp;lt;Dto1&amp;gt;(result, page);
    }

    @Override
    protected List&amp;lt;Dto1&amp;gt; computeResultList(Range range , String criteria) {
        CriteriaQuery&amp;lt;AggRoot1&amp;gt; query = getAggRoot1CriteriaQuery(criteria);
        List&amp;lt;AggRoot1&amp;gt; resultList = entityManager.createQuery(query)
                .setFirstResult((new BigDecimal(range.getOffset()).intValue()))
                .setMaxResults(new BigDecimal(range.getSize()).intValue())
                .getResultList();

        return assemblers.assembleDtoFromAggregate(resultList);
    }

    @Override
    protected long computeFullRequestSize(String criteria) {
        CriteriaQuery&amp;lt;Long&amp;gt; query = getAggRoot1CountCriteriaQuery(criteria);
        return entityManager.createQuery(query).getSingleResult();
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, inject the finder with its interface and use it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Inject
Dto1Finder dto1Finder;

@GET
@Rel(&amp;quot;search&amp;quot;)
@Produces(MediaType.APPLICATION_JSON)
public Response list(@QueryParam(&amp;quot;q&amp;quot;) String searchQuery,
                     @DefaultValue(&amp;quot;0&amp;quot;) @QueryParam(&amp;quot;pageIndex&amp;quot;) Long pageIndex,
                     @DefaultValue(&amp;quot;10&amp;quot;) @QueryParam(&amp;quot;pageSize&amp;quot;) Integer pageSize) {

    // Call the finder with the requested page
    Page page = new Page(pageIndex, pageSize);
    PaginatedView&amp;lt;Dto1&amp;gt; view = dto1Finder.findItemByQuery(page, searchQuery);

    // Create an HAL representation with the page and the total number of elements
    Dto1sRepresentation representation = new Dto1sRepresentation(page,
        view.getResultSize());

    // Add the list of item to the representation
    representation.embedded(&amp;quot;items&amp;quot;, view.getView());

    // If a next page is available add to link to it
    if (view.hasNext()) {
        Page next = view.next();

        representation.link(&amp;quot;next&amp;quot;, relRegistry.uri(&amp;quot;search&amp;quot;)
                .set(&amp;quot;pageIndex&amp;quot;, next.getIndex())
                .set(&amp;quot;pageSize&amp;quot;, next.getCapacity()).expand());
    }

    // If a previous page is available add to link to it
    if (view.hasPrev()) {
        Page prev = view.prev();

        representation.link(&amp;quot;prev&amp;quot;, relRegistry.uri(&amp;quot;search&amp;quot;)
                .set(&amp;quot;pageIndex&amp;quot;, prev.getIndex())
                .set(&amp;quot;pageSize&amp;quot;, prev.getCapacity()).expand());
    }

    return Response.ok(representation).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;The following example uses the HAL media type. For more information about it, read the documentation about
&lt;a href=&#34;http://seedstack.org/archives/16.7/docs/seed/manual/rest/#restful-api&#34;&gt;hypermedia&lt;/a&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Policies</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/policies/</guid>
      <description>&lt;p&gt;A policy is a variant of the Strategy pattern to encapsulate one or more business rules.&lt;/p&gt;

&lt;h1 id=&#34;definition&#34;&gt;Definition&lt;/h1&gt;

&lt;p&gt;Creating a Policy with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a policy interface in the domain,&lt;/li&gt;
&lt;li&gt;Creating a policy implementation, located either in the domain or in the infrastructure if it depends upon any
specific technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Business Framework Policies are POJOs, there is no mandated interface. Just annotate your policy interface with the
&lt;code&gt;@DomainPolicy&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;To use a policy, simply inject it in your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
MyPolicy myPolicy;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s consider a bonus policy for car sellers according to the sales they&amp;rsquo;ve done.
This policy could allow the sellers - and their manager - to know what the amount of their bonus is at a given time in
the current month.&lt;/p&gt;

&lt;h2 id=&#34;bonuspolicy-interface&#34;&gt;BonusPolicy interface&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;org.mycompany.myapp.policy&lt;/code&gt; package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.policy;

import org.mycompany.myapp.domain.model.carsold.CarSold;
import org.mycompany.myapp.domain.shared.vo.Price;
import org.seedstack.business.domain.DomainPolicy;

import java.util.List;

@DomainPolicy
public interface BonusPolicy {
	Price computeBonus(List&amp;lt;CarSold&amp;gt; carSolds);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bonuspolicy-implementation&#34;&gt;BonusPolicy implementation&lt;/h2&gt;

&lt;p&gt;Below is an implementation example.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;org.mycompany.myapp.policy.internal&lt;/code&gt; package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.policy.internal;

import ...

public class BonusPolicyInternal implements BonusPolicy{

    @Override
	public Price computeBonus(List&amp;lt;CarSold&amp;gt; soldCarsList) {
        ...
		return finalBonus;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bonuspolicy-usage&#34;&gt;BonusPolicy usage&lt;/h2&gt;

&lt;p&gt;Wherever the policy is used to compute the bonus of a particular employee, just retrieve the cars sold by this employee
(through the sold cars repository) and call the policy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Interface&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.application.service;

import org.mycompany.myapp.domain.model.employee.Employee;
import org.seedstack.business.Service;

@Service
public interface SalesBonusService {
    double calculateCurrentBonusFor(Employee employee);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.application.service.internal;

import ...

public class SalesBonusServiceInternal implements SalesBonusService {
	
	@Inject
	CarSoldRepository carSoldRepository;
	
	@Inject
	CarForSaleRepository carForSaleRepository;
	
	@Inject
	BonusPolicy bonusPolicy;
	
	@Override
	public double calculateCurrentBonusFor(Employee employee) {
		List&amp;lt;CarSold&amp;gt; findByEmployee = carSoldRepository
             .findByEmployee(employee.getEntityId());
		Price bonus = bonusPolicy.computeBonus(findByEmployee);
		return bonus.getPriceValue();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, one can just inject the service and compute a bonus whenever an &lt;code&gt;Employee&lt;/code&gt; entity is at reach (eg. while building
an employee profile page).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Repositories</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/repositories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/repositories/</guid>
      <description>&lt;p&gt;A repository is a pattern used to store and retrieve Aggregates from persistence with a &lt;strong&gt;simple and global interface&lt;/strong&gt;,
providing the illusion of an in-memory collection. A repository manipulates a whole aggregate through its aggregate
root and ensures that it is persisted and retrieved in a coherent manner.&lt;/p&gt;

&lt;h1 id=&#34;default-repository&#34;&gt;Default repository&lt;/h1&gt;

&lt;p&gt;The Business Framework provides a default repository that can perform CRUD actions on an aggregate.
It can be injected with the &lt;code&gt;Repository&lt;/code&gt; interface and a qualifier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject @Jpa
private Repository&amp;lt;Customer, String&amp;gt; customerRepo;

...
Customer customer = customerRepo.load(customerId);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;By default, you have to explicitly specify the qualifier.
But if you have only one persistence and one default repository, you can configure the one to use.
The default repository can be configured for all the application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.example.*]
default-repository=org.seedstack.jpa.Jpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also override it for a specific aggregate root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.example.domain.customer.Customer]
default-repository=another-qualifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;default.repository.qualifier&lt;/code&gt; property expects a qualifier annotation class or a string when the qualifier use &lt;code&gt;@Named(&amp;quot;another-qualifer&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;custom-repository&#34;&gt;Custom repository&lt;/h1&gt;

&lt;p&gt;The default CRUD repository is interesting to start quickly and might be enough for some use cases. But it is possible to
add your own repositories, in order to extend the CRUD behavior with your domain
requirements.&lt;/p&gt;

&lt;p&gt;First create a repository interface extending &lt;code&gt;GenericRepository&lt;/code&gt;. This interface is usually located in the aggregate package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.seedstack.business.domain.Repository;

public interface OrderRepository extends GenericRepository&amp;lt;Order, Long&amp;gt; {

     Order findOrderByCategory(String categoryId)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is possible not to use the &lt;code&gt;GenericRepository&lt;/code&gt; interface and instead annotate the class with the &lt;code&gt;@DomainRepository&lt;/code&gt; annotation.
But you won&amp;rsquo;t be able to use the framework&amp;rsquo;s helpers like the assembler DSL &lt;code&gt;fromRepository()&lt;/code&gt; method.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then add an implementation in the infrastructure layer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class OrderJpaRepository extends BaseJpaRepository&amp;lt;Order, Long&amp;gt; implements OrderRepository {

    @Override
    public Order findOrderByCategory(String categoryId){ ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;An explicit repository can be injected like a default one (with the &lt;code&gt;Repository&lt;/code&gt; interface):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private Repository&amp;lt;Order, Long&amp;gt; repository;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or with its own interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private OrderRepository repository;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>