<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://seedstack.org/archives/16.7/tags/pattern/index.xml</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://seedstack.org/archives/16.7/tags/pattern/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Aggregates</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/aggregates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/aggregates/</guid>
      <description>&lt;p&gt;Domain objects have a lifecycle: they are created, go through various states and eventually die (either being archived
or deleted). Many of these objects are simple, transient objects which are simply created with a call to their constructor
and thrown away after use. There is no need to complicate such objects. But some objects are more rich, with a complex
lifecycle and numerous relationships with other objects.&lt;/p&gt;

&lt;p&gt;The challenges of managing these objects can also be addressed with several patterns. The first one is the &lt;strong&gt;aggregate pattern,
which define clear ownership and boundaries between domain objects&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-is-an-aggregate&#34;&gt;What is an aggregate ?&lt;/h1&gt;

&lt;p&gt;Most business domains have very interconnected entities, sometimes up to the point where there is always a path going from
any Entity to any other. We can try to minimize the number of associations in our design, and this is a good practice
but it can lead to a translation loss between business and software. In a typical object model, it is difficult to clearly
see the boundaries of a change. This is particularly acute in systems with concurrent access such as Web applications.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is also difficult to guarantee the consistency of changes to objects in a model with complex associations and no clear
boundaries between objects. Considering every object as independent from each other is not a valid approach, but on the
other side, refreshing every object because of a change is not practical. &lt;strong&gt;A balanced solution must be found&lt;/strong&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;../img/aggregate-typologies.png&#34; alt=&#34;Aggregate typologies&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the &lt;strong&gt;aggregate pattern&lt;/strong&gt;, we want to be as close as possible to the center pattern in the figure above. The aggregate
is a cluster of associated objects that are considered as a unit for the purpose of data changes. Each Aggregate has root
and a boundary which determines what is inside the Aggregate.&lt;/p&gt;

&lt;p&gt;The Aggregate root is a specific Entity contained in the Aggregate. It is the only entry-point of the Aggregate, meaning
that it is the only Aggregate Entity that client objects can hold references to. Other objects of the Aggregate are only
accessible through the context of the Aggregate root.&lt;/p&gt;

&lt;h1 id=&#34;characteristics&#34;&gt;Characteristics&lt;/h1&gt;

&lt;p&gt;The following rules apply to Aggregates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Aggregate root has a global identity and is responsible for checking invariants within the Aggregate.&lt;/li&gt;
&lt;li&gt;Non-root Entities inside the Aggregate have a local identity that is only unique within the Aggregate.&lt;/li&gt;
&lt;li&gt;Code outside the Aggregate can only hold references to the Aggregate root. The root can hand references to internal
entities but they must only use them transiently and not hold to the reference. Value Objects can be handed without
any concern because they are immutable and side-effect free.&lt;/li&gt;
&lt;li&gt;Only Aggregate roots can be loaded directly from the persistence. All other objects must be found by traversal of
associations.&lt;/li&gt;
&lt;li&gt;Any change within the Aggregate boundary must satisfy all the Aggregate invariants.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;declaration&#34;&gt;Declaration&lt;/h1&gt;

&lt;p&gt;Creating an Aggregate with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a package with the Aggregate name,&lt;/li&gt;
&lt;li&gt;Create all the domain objects belonging to the Aggregate in this package,&lt;/li&gt;
&lt;li&gt;From all those domain objects, one Entity should be created as the &lt;strong&gt;Aggregate root&lt;/strong&gt;. This step is the focus of this
section.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To create an Aggregate root using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseAggregateRoot&lt;/code&gt; class. This class directly extends &lt;code&gt;BaseEntity&lt;/code&gt; and as such the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;
and &lt;code&gt;compareTo()&lt;/code&gt; methods will be provided out-of-the-box.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;AggregateRoot&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;compareTo()&lt;/code&gt; methods in
this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainAggregateRoot&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the two first options (base class and interface), you have to provide a generic parameter with the type of the
Aggregate root identifier.&lt;/p&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public class Order extends BaseAggregateRoot&amp;lt;Long&amp;gt; {
    private Long orderId;
    private Date checkoutDate;
    private double price;
    private List&amp;lt;OrderItem&amp;gt; items;

    Order() {
    }

    @Override
    public Long getEntityId() {
        return orderId;
    }

    public void addOrderItem(int quantity, long productId, double price) {
        OrderItem orderItem = new OrderItem();
        orderItem.setQuantity(quantity);
        orderItem.setProductId(productId);
        orderItem.setPrice(price);
        items.add(orderItem);
    }

    public void clearOrderItems() {
        items.clear();
    }

    public Long getOrderId() {
        return orderId;
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Assemblers</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/assemblers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/assemblers/</guid>
      <description>&lt;p&gt;The assembler pattern is used to transfer a representation of the state of &lt;em&gt;Aggregates&lt;/em&gt; to &lt;em&gt;DTO/Representation&lt;/em&gt; objects.
The Business Framework provides a interface and few base classes to ease the development of assemblers.&lt;/p&gt;

&lt;h1 id=&#34;default-assembler&#34;&gt;Default assembler&lt;/h1&gt;

&lt;p&gt;By default, if your mapping is obvious, you don&amp;rsquo;t have to create an explicit assembler. You just add the &lt;code&gt;@DtoOf&lt;/code&gt; annotation
on your DTO class to link them to their related Aggregate root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DtoOf(Product.class)
class ProductRepresentation {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then inject a ModelMapper-based assembler with the &lt;code&gt;@ModelMapper&lt;/code&gt; annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
@ModelMapper
Assembler&amp;lt;Product, ProductRepresentation&amp;gt; productAssembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This assembler uses the default settings of the &lt;a href=&#34;http://modelmapper.org/&#34;&gt;ModelMapper library&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-warning&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
            
                &lt;i class=&#34;fa fa-exclamation-triangle icon-2x&#34;&gt;&lt;/i&gt;
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is strongly recommended to always have a DTO. &lt;strong&gt;Never serialize domain objects to your clients.&lt;/strong&gt; Even with the default
assembler you can define a DTO that is a flat and/or partial mapping of your domain Aggregate. ModelMapper will
automatically figure out the field mapping if you respect &lt;a href=&#34;http://modelmapper.org/getting-started/#mapping&#34;&gt;their conventions&lt;/a&gt;.
Besides, you should always have integration tests that checks that the automatic mapping is correct.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;explicit-assembler&#34;&gt;Explicit assembler&lt;/h1&gt;

&lt;p&gt;Create an assembler extending &lt;code&gt;BaseAssembler&lt;/code&gt; class. It will contains
the logic of the copy between aggregate and DTO. Then, inject your
assembler in your class.&lt;/p&gt;

&lt;p&gt;There are two methods to implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;doAssembleDtoFromAggregate(dto, aggregate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doMergeAggregateWithDto(aggregate, dto)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first method creates a DTO from an aggregate root. The second
merge the mutable fields of an &lt;strong&gt;existing&lt;/strong&gt; aggregate with the data
from the dto.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Note that the aggregate identity should never be updated by the DTO.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;An assembler assembling a representation of a product.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProductAssembler extends BaseAssembler&amp;lt;Product,ProductRepresentation&amp;gt; {

    @Override
    protected void doAssembleDtoFromAggregate(ProductRepresentation targetDto, 
	         Product sourceAggregate) {
        // Flatten the id
        targetDto.setStoreId(sourceAggregate.getAggregateId().getStoreId());
        targetDto.setProductCode(sourceAggregate.getAggregateId().getProductCode());
         
        targetDto.setName(sourceAggregate.getName());
        targetDto.setDescription(sourceAggregate.getDescription());
    }
	 
    @Override
    protected void doMergeAggregateWithDto(Product targetAggregate, 
	        ProductRepresentation sourceDto) {
        // The id is not modified
        targetAggregate.setName(sourceDto.getName());
        targetAggregate.setDescription(sourceDto.getDescription());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can inject the assembler via its interface or directly via the
implementation class. Both way are acceptable, but the first way
provides a more encapsulated interface to the developer using it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
Assembler&amp;lt;Product, ProductRepresentation&amp;gt; productAssembler;

@Inject
ProductAssembler productAssembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// assemble a representation
representation = productAssembler.assembleDtoFromAggregate(product);

// merge an aggregate
Product productToMerge = catalog.retrieve(productId);
productAssembler.mergeAggregateWithDto(productToMerge, productRepresentationSource);
catalog.update(productToMerge);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;domain-specific-language&#34;&gt;Domain-Specific Language&lt;/h1&gt;

&lt;p&gt;Assembler implementations remains simple, but its usage can become
tedious when using lists or complexe worflows. To simplify this use
cases the Business Framework provides a DSL throught
&lt;code&gt;FluentAssembler&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;lists&#34;&gt;Lists&lt;/h2&gt;

&lt;p&gt;Replace common boilerplate code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;ProductRepresentation&amp;gt; representations = new ArrayList&amp;lt;&amp;gt;();
for (Product product : products {
    representations.add(productAssembler.assembleDtoFromAggregate(product))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;by oneliners:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.assemble(products).to(ProductRepresentation.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tuples&#34;&gt;Tuples&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.assemble(product, order).to(RecipeRepresentation.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;qualified-assemblers&#34;&gt;Qualified assemblers&lt;/h2&gt;

&lt;p&gt;You can specify the assembler the DSL should use by specifying a
qualifier.
For instance, the following example use the &lt;strong&gt;default ModelMapper
assembler&lt;/strong&gt;.
So in this case you don&amp;rsquo;t even have to create an assembler class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluently.assemble(products).with(AssemblerTypes.MODEL_MAPPER).to(MyDto.class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;advanced-usage&#34;&gt;Advanced usage&lt;/h2&gt;

&lt;p&gt;When we merge a representation to an aggregate, the assembler expects
an existing aggregate root instance. Normally you have to retreive
this instance from a repository or to create it from a factory. This
can become a little tedious when you have to do it a lot. Or by adding
few metadata to your DTO, you can have the DSL doing it for you.&lt;/p&gt;

&lt;h3 id=&#34;get-an-aggregate-from-its-factory&#34;&gt;Get an aggregate from its factory&lt;/h3&gt;

&lt;p&gt;If the aggregate root to merge doesn&amp;rsquo;t exists, you can tell the DSL to
create it from its factory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluentAssembler.merge(repr).into(Product.class).fromFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will search the aggregate root&amp;rsquo;s factory
(&lt;code&gt;GenericFactory&amp;lt;Product&amp;gt;&lt;/code&gt;). Then it will search the appropriate
method to call. In order to indicate to the DSL which method should be called,
annotate the DTO&amp;rsquo;s getters matching the factory method&amp;rsquo;s parameters
with &lt;code&gt;@MatchingFactoryParameter(index=0)&lt;/code&gt;. The index represents the
position of the parameters in the factory method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProductRepesentation {

    private Short storeId;
    private Short productCode;
    private String name;
    private String description

    @MatchingFactoryParameter(index=0)
    public Short getStoreId() { ... }

    @MatchingFactoryParameter(index=1)
    public Short getProductCode() { ... }

    @MatchingFactoryParameter(index=2)
    public Short getName() { ... }

    public Short getDescription() { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public interface ProductFactory extends GenericFactory&amp;lt;Product&amp;gt; {

	Product createProduct(Short storeId, Short productCode, String name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-an-aggregate-from-its-repository&#34;&gt;Get an aggregate from its repository&lt;/h3&gt;

&lt;p&gt;If the aggregate root to merge already exists, you can tell the DSL to
get it from its repository. If the DSL doesn&amp;rsquo;t find the aggregate root
from the repository, two strategies are possible. The first throw an
exception, the second fall back to the &lt;code&gt;fromFactory()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    product = fluentAssembler.merge(representation).into(Product.class)
        .fromRepository().orFail();

} catch (AggregateNotFoundException e) {
    return Response.status(Response.Status.NOT_FOUND).build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;product = fluentAssembler.merge(repr).into(Product.class)
    .fromRepository().thenFromFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will search the aggregate root&amp;rsquo;s repository
(&lt;code&gt;GenericRepository&amp;lt;Product&amp;gt;&lt;/code&gt;). Then it will call its &lt;code&gt;load()&lt;/code&gt;
method.
In order to indicate to the DSL how to find the ID,
annotate the DTO getter matching the aggregate root ID with
&lt;code&gt;@MatchingEntityId&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;If the ID is composite annotate the getter
methods matching the ID constructor parameters with
&lt;code&gt;@MatchingEntityId(index=0)&lt;/code&gt;. In this case, the index is mandatory and
represents the position of the parameters in the constructor method.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;public class ProductRepesentation {

    private Short storeId;
    private Short productCode;
    private String name;
    private String description

    @MatchingEntityId(index=0)
    public Short getStoreId() { ... }

    @MatchingEntityId(index=1)
    public Short getProductCode() { ... }

    public Short getName() { ... }

    public Short getDescription() { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ProductId extends BaseValueObject {

	private Short storeId;
	private Short productCode;

	public ProductId(Short storeId, Short productCode) {
		this.storeId = storeId;
		this.productCode = productCode;
	}

    // Getters ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;automation-with-modelmapper&#34;&gt;Automation with ModelMapper&lt;/h1&gt;

&lt;p&gt;DTOs are meant to expose domain objects or a part of these objects.
So there are often similarities between the DTOs and the domain
object.
This can lead to a lot of boilerplate code when the assembler doesn&amp;rsquo;t
hold complex logic but just populates objects.&lt;/p&gt;

&lt;p&gt;For this use case, you can now &lt;strong&gt;use a default&lt;/strong&gt; assembler based on
&lt;a href=&#34;http://modelmapper.org/&#34;&gt;ModelMapper&lt;/a&gt;. It&amp;rsquo;s an &lt;em&gt;automatic assembler&lt;/em&gt;
which provides an &lt;strong&gt;intelligent mapping&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-to-use-it&#34;&gt;How to use it ?&lt;/h2&gt;

&lt;p&gt;The only thing you have to do is to annotate the DTO with
&lt;code&gt;@DtoOf(MyAggregate.class)&lt;/code&gt;. It tells the framework to bind a default
assembler for assembling &lt;code&gt;MyAggregate&lt;/code&gt; into the annotated DTO.
After you can inject the assembler as follows, and use it as usual.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DtoOf(MyProduct.class)
public class MyDto { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Inject
@ModelMapper
private Assembler&amp;lt;MyAggregate,MyDto&amp;gt; myDtoAssemebler;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-does-it-work&#34;&gt;How does it work ?&lt;/h2&gt;

&lt;p&gt;It uses a intelligent mapping provided by the ModelMapper library.
You can find the detailed explanation here
&lt;a href=&#34;http://modelmapper.org/user-manual/how-it-works/&#34;&gt;matching documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;can-i-customize-it&#34;&gt;Can I customize it ?&lt;/h2&gt;

&lt;p&gt;Yes. If there are ambiguities, or if you only want to change the mapping of
one field, you don&amp;rsquo;t need to fall back to the old assembler. You can
just create an assembler extending the &lt;code&gt;ModelMapperAssembler&lt;/code&gt; class and
implement the methods returning a &lt;code&gt;ModelMapper&lt;/code&gt; instance.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;See here &lt;a href=&#34;http://modelmapper.org/user-manual/property-mapping/&#34;&gt;how to override the mapping&lt;/a&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;It supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deep mapping&lt;/li&gt;
&lt;li&gt;Skipping properties&lt;/li&gt;
&lt;li&gt;Providers&lt;/li&gt;
&lt;li&gt;Conditional mapping&lt;/li&gt;
&lt;li&gt;String mapping&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;can-i-see-some-code&#34;&gt;Can I see some code ?&lt;/h3&gt;

&lt;p&gt;Below is an example from the &lt;a href=&#34;https://github.com/seedstack/store-webapp-sample&#34;&gt;Web application sample&lt;/a&gt;.
The Product contains a field &lt;code&gt;entityId&lt;/code&gt; and a field &lt;code&gt;categoryId&lt;/code&gt;, but the representation only contains a field
&lt;code&gt;id&lt;/code&gt;. So ModelMapper doesn&amp;rsquo;t know which field match.&lt;/p&gt;

&lt;p&gt;To fix this, extend &lt;code&gt;ModelMapperAssembler&lt;/code&gt; and add a &lt;code&gt;PropertyMap&lt;/code&gt; to the &lt;code&gt;modelMapper&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Note that, as you implemented an assembler, you don&amp;rsquo;t use the default
assembler anymore. So remove the &lt;code&gt;@DtoOf&lt;/code&gt; annotation on the DTO.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;public class ProductModelMapperAssembler extends ModelMapperAssembler&amp;lt;Product, ProductRepresentation&amp;gt; {

    @Override
    protected void configureAssembly(ModelMapper modelMapper) {
        modelMapper.addMappings(new PropertyMap&amp;lt;Product, ProductRepresentation&amp;gt;() {
            @Override
            protected void configure() {
                // Required due to the ambiguity with the categoryId field
                map().setId(source.getEntityId());
            }
        });
    }

    @Override
    protected void configureMerge(ModelMapper modelMapper) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use it as usual.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private Assembler&amp;lt;Product, ProductRepresentation&amp;gt; assembler;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;assembler.assembleDtoFromAggregate(aProduct);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>Domain events</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/events/</guid>
      <description>&lt;p&gt;Seed Business Framework contains an API to manage domain events. The &lt;code&gt;EventService&lt;/code&gt; service is used to fire events. Events
must be immutable and extend &lt;code&gt;DomainEvent&lt;/code&gt; (which extends &lt;code&gt;BaseValueObject&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; Events can also be defined by implementing the &lt;code&gt;Event&lt;/code&gt; interface. Nevertheless, this requires to
implement &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods. Otherwise event test fixtures and call cycle detection will not work.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;For instance this event&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyEvent extends DomainEvent {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;could be fired as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventService

@Inject
private MyEventFactory eventFactory;

eventService.fire(eventFactory.createMyEvent());
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;handling-events&#34;&gt;Handling events&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;EventHandlers&lt;/strong&gt; must implement &lt;code&gt;EventHandler&lt;/code&gt; in order to receive fired events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyHandler implements EventHandler&amp;lt;MyEvent&amp;gt; {
    @Override
    public void handle(MyEvent event) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyHandler&lt;/code&gt; implements &lt;code&gt;EventHandler&amp;lt;MyEvent&amp;gt;&lt;/code&gt; which means it listens to events of &lt;code&gt;MyEvent&lt;/code&gt; type.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt; method has to be implemented to define the handler&amp;rsquo;s behaviour.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;synchronous-behavior&#34;&gt;Synchronous behavior&lt;/h2&gt;

&lt;p&gt;Events are fired synchronously and &lt;strong&gt;belong to current transaction&lt;/strong&gt;. Depending on &lt;code&gt;Exception&lt;/code&gt; management, a fired exception might rollback the transaction.&lt;/p&gt;

&lt;h2 id=&#34;event-inheritance&#34;&gt;Event inheritance&lt;/h2&gt;

&lt;p&gt;If a triggered event is assignable to &lt;code&gt;MyEvent&lt;/code&gt; (by inheritance), it will also be handled - consequently, a handler that &lt;code&gt;implements EventHandler&amp;lt;DomainEvent&amp;gt;&lt;/code&gt; will be called on any event implementing &lt;code&gt;DomainEvent&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;testing-events&#34;&gt;Testing events&lt;/h1&gt;

&lt;p&gt;The &lt;strong&gt;seed-business-core-test&lt;/strong&gt; module provides an &lt;code&gt;EventFixture&lt;/code&gt; class for integration tests on events.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was handled by an expected &lt;code&gt;EventHandler&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasHandledBy(MyHandler.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was handled by exactly a provided list of &lt;code&gt;EventHandler&lt;/code&gt;s:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasHandledExactlyBy(MyHandler.class, MyHandler2.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was not handled by an expected  &lt;code&gt;EventHandler&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
fixture.given(eventFactory.createMyEvent())
    .whenFired()
    .wasNotHandledBy(MyHandler3.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test that a given event was generated from an expected &lt;code&gt;method()&lt;/code&gt; with appropriate &lt;em&gt;parameters&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private EventFixture fixture;
...
MyEvent myEvent = eventFactory.createMyEvent(SOME_EVENT_PARAM);
fixtures.given(MyService.class)
     .whenCalled(&amp;quot;doSomething&amp;quot;, SOME_METHOD_PARAM)
     .eventWasHandledBy(myEvent, MyHandler.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test if &lt;code&gt;MyHandler&lt;/code&gt; handler received &lt;code&gt;myEvent&lt;/code&gt; event when &lt;code&gt;doSomething()&lt;/code&gt; method of &lt;code&gt;MyService&lt;/code&gt; is called.&lt;/p&gt;

&lt;h1 id=&#34;provided-events&#34;&gt;Provided events&lt;/h1&gt;

&lt;h2 id=&#34;aggregate-events&#34;&gt;Aggregate events&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Seed Business Framework&lt;/strong&gt; provides following events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AggregateReadEvent&lt;/code&gt;: triggered when reading an aggregate - eg. repository &lt;code&gt;load()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AggregatePersistedEvent&lt;/code&gt;: triggered when persisting an aggregate - eg. repository &lt;code&gt;save()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AggregateDeletedEvent&lt;/code&gt;: triggered when deleting an aggregate - eg. repository &lt;code&gt;delete()&lt;/code&gt; method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Above behaviour is defined by method annotations, respectively: &lt;code&gt;@Read&lt;/code&gt;, &lt;code&gt;@Persist&lt;/code&gt; and &lt;code&gt;@Delete&lt;/code&gt;.
These annotations are only intercepted (and functional) within a repository class implementing &lt;code&gt;GenericRepository&lt;/code&gt; (read &lt;a href=&#34;#!/business-doc/hands-on-domain/repository&#34;&gt;more&lt;/a&gt; on repositories).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This mechanism is disabled by default.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To enable this feature, use following property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.seedstack.business.event]
domain.watch=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handle aggregate read events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define a custom read method:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public interface MyRepository extends GenericRepository&amp;lt;AgregateRoot, AggregateIdKey&amp;gt; {
    ...
    @Read
    AgregateRoot loadByName(String name);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;GenericRepository&lt;/code&gt; methods (load, delete, persist, save) are already annotated with appropriate annotations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;The repository reading method is called, triggering an &lt;code&gt;AggregateReadEvent&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// fire an AggregateReadEvent for the AgregateRoot
productRepository.loadByName(aggregateName);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyHandler&lt;/code&gt; handles the triggered &lt;code&gt;AggregateReadEvent&lt;/code&gt; event:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// handle an AggregateReadEvent
class MyHandler implements EventHandler&amp;lt;AggregateReadEvent&amp;gt; {
    public void handle(BaseRepositoryEvent event) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; Above handler receives all &lt;code&gt;AggregateReadEvent&lt;/code&gt; from any repository
&lt;code&gt;@Read&lt;/code&gt; annotated method. Since &lt;code&gt;AggregateReadEvent&lt;/code&gt; events contain the aggregate root
class and a context with the called method and its arguments, the handler behaviour can be defined accordingly.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Since all &amp;laquo;aggregate events&amp;raquo; extend &lt;code&gt;BaseAggregateEvent&lt;/code&gt;, it is possible to intercept them all in one handler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// handle an BaseAggregateEvent
class MyHandler implements EventHandler&amp;lt;BaseAggregateEvent&amp;gt; {
    public void handle(BaseRepositoryEvent event) {
        // if &amp;quot;event&amp;quot; depends on Product aggregate
        if (Product.class.isAssignableFrom(event.getAggregateRoot())) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;See above &lt;a href=&#34;#!/business-doc/hands-on-domain/events#handling-events&#34;&gt;handlers&lt;/a&gt; documentation for more detail about their generic behaviour.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Domain model</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/model/</guid>
      <description>&lt;p&gt;The domain model is expressed through three patterns:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Entity&lt;/strong&gt; which is an object defined primarily by its identity.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value Object&lt;/strong&gt; which is an object with no conceptual identity and solely defined by is attributes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service&lt;/strong&gt; which hold domain logic that doesn&amp;rsquo;t clearly belong to an entity nor a value object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;entities&#34;&gt;Entities&lt;/h1&gt;

&lt;p&gt;Entities are used to represent a domain concept which has an identity.&lt;/p&gt;

&lt;p&gt;Often DDD beginners have a tendency to focus more on data than on the software. This often leads in all the concepts of
the &amp;laquo;domain&amp;raquo; being coded as entities. Specially, in anemic entities using only getters and setters. Using them is not
wrong but it&amp;rsquo;s not enough to hold the insights of a domain. That&amp;rsquo;s why designing entities should be taken very carefully.&lt;/p&gt;

&lt;p&gt;The entity concept should be used for an element of your domain when you take care of its identity. An identity must be
unique and immutable. Even it an object can change during its lifetime, its identity must stay untouched. If this is not
true for your element, you should consider using a &lt;a href=&#34;#value-objects&#34;&gt;value object&lt;/a&gt; instead.&lt;/p&gt;

&lt;p&gt;When designing an entity, the critical part is to determine what is the identity and how to create it. An identity can be
hold by a set of properties. In this case, a value object can be well fitted to guaranty the identity consistency and immutability.&lt;/p&gt;

&lt;p&gt;There are different kind of creation strategies for identities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The client can pass values handling himself the uniqueness.&lt;/li&gt;
&lt;li&gt;The application can generate the identity using an algorithm.&lt;/li&gt;
&lt;li&gt;The application can rely on an external identity generator, like a database sequence.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first case is easily handled using factories. The other cases, can be usually more complicated, but the Business
framework provides an API for them (see &lt;a href=&#34;http://seedstack.org/archives/16.7/docs/business/manual/factories/#identity-generation&#34;&gt;identity generation&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;declaration&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;To create an Entity using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseEntity&lt;/code&gt; class. The &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods will be provided out-of-the-box as well as a basic  &lt;code&gt;toString()&lt;/code&gt; method. You must implement the &lt;code&gt;getEntityId()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;Entity&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;getEntityId()&lt;/code&gt;
methods in this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainEntity&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With the two first options (base class and interface), you have to provide a generic parameter with the type of the
Entity identifier.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Consider the following example in which a &lt;code&gt;Customer&lt;/code&gt; Entity is identified by an e-mail of String type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Customer extends BaseEntity&amp;lt;String&amp;gt; {
    private String email;
    private Address address;

    public Customer (String email) {
        this.email = email;
    }

    @Override
    public String getEntityId() {
        return this.email;
    }

    /* Meaningful methods */
    public void changeAddress(Address newAddress) { ... }

    /* Getters */
    public Address getAddress() { ... }
    public String getEmail() { ... }
    public List&amp;lt;Order&amp;gt; getOrders() { ... }
    
    /* Try to avoid setters as they allow to alter the internal state of the entity */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;value-objects&#34;&gt;Value-Objects&lt;/h1&gt;

&lt;p&gt;An object that don&amp;rsquo;t have a conceptual identity but is just describing some characteristics of a thing is called a
Value Object. Because the most visible objects in a model are usually Entities, there is a natural tendency to assign
an identity to every domain object. But this tendency should be refrained. Here are the main characteristics of a
Value Object:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It measures, quantifies or describes a thing in the domain.&lt;/li&gt;
&lt;li&gt;It is immutable, meaning that its state cannot be changed after creation.&lt;/li&gt;
&lt;li&gt;It describes a conceptual whole. Its attributes are related to each other and are all participating to the description.
This means that all the required values should be assigned upon creation (i.e. in the constructor).&lt;/li&gt;
&lt;li&gt;It is comparable to others using value equality.&lt;/li&gt;
&lt;li&gt;Its behavior is side-effect free.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;declaration-1&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;To create a Value Object using the Business framework you have three choices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;BaseValueObject&lt;/code&gt; class. In this case, the &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; methods will be
provided out-of-the-box as well as a basic &lt;code&gt;toString()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Implement the &lt;code&gt;ValueObject&lt;/code&gt; interface. You must implement the &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; in this case.&lt;/li&gt;
&lt;li&gt;Simply annotate any class with the &lt;code&gt;@DomainValueObject&lt;/code&gt; annotation. In this case, you won&amp;rsquo;t be able to use helpers and
tools from the framework.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-1&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Cars are identified by a &amp;laquo;Vehicle Identification Number&amp;raquo; (VIN). See this &lt;a href=&#34;http://en.wikipedia.org/wiki/Vehicle_Identification_Number#Components_of_the_VIN&#34;&gt;wikipedia article&lt;/a&gt;
for the conceptual definition. To simplify our example, we will just consider the VIN as composed respectively of 3 parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3 DIGITS : World Manufacturer Identifier&lt;/li&gt;
&lt;li&gt;6 DIGITS : Vehicle descriptor section&lt;/li&gt;
&lt;li&gt;8 DIGITS : Vehicle identifier section&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a possible implementation of the VIN class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.shared.domain.after.sales.vehicle;

import org.seedstack.business.domain.BaseValueObject;

public class VIN extends BaseValueObject {
    private final String worldManufacturerIdentifier;
    private final String vehicleDescriptorSection;
    private final String vehicleIdentifierSection;

    public vehicleIdentificationNumber(
            String worldManufacturerIdentifier,
            String vehicleDescriptorSection,
            String vehicleIdentifierSection) {
        this.worldManufacturerIdentifier = worldManufacturerIdentifier;
        this.vehicleDescriptorSection = vehicleDescriptorSection;
        this.vehicleIdentifierSection = vehicleIdentifierSection;
    }

    public vehicleIdentificationNumber(String vin) {
        this.worldManufacturerIdentifier = vin.substring(0,3);
        this.vehicleDescriptorSection = vin.substring(3,9);
        this.vehicleIdentifierSection = vin.substring(9,17);
    }

    /* Getters */
    public String getWorldManufacturerIdentifier() { ... }
    public String getVehicleDescriptorSection() { ... }
    public String getVehicleIdentifierSection() { ... }

    @Override
    public String toString(){
        return worldManufacturerIdentifier + vehicleDescriptorSection
                + vehicleIdentifierSection;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;usage-as-identifiers&#34;&gt;Usage as identifiers&lt;/h2&gt;

&lt;p&gt;Value Object can also be used to represent complex identifiers for entities. For instance, you can use the VIN class defined
in the example above to identity a &lt;code&gt;Vehicle&lt;/code&gt; class. You can also add meaning and behavior to a simple value by embedding
it into a Value Object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.customer;

import javax.persistence.Embeddable;
import org.seedstack.business.domain.BaseValueObject;

public class CustomerId extends BaseValueObject {
    private String value;

    public CustomerId(String customerId) {
        this.value = customerId;
    }
    public String getValue() {
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the &lt;code&gt;CustomerId&lt;/code&gt; Value Object add meaning to the plain string. You won&amp;rsquo;t manipulate a String anymore
in your code but a CustomerId, with its own type. This type can evolve later to provide additional behavior or to
be adapt its internal structure.&lt;/p&gt;

&lt;h1 id=&#34;services&#34;&gt;Services&lt;/h1&gt;

&lt;p&gt;Services are stateless objects that implement logic which doesn&amp;rsquo;t fit in the aggregates.&lt;/p&gt;

&lt;p&gt;Services can be found in various locations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The domain, where services contain pure business logic. Naming should come from the &lt;a href=&#39;http://seedstack.org/archives/16.7/glossary#ubiquitous-language&#39;&gt;ubiquitous language&lt;/a&gt; or
be introduced into it if necessary. Parameters and return values should be domain objects. Example: a bank account transfer service.&lt;/li&gt;
&lt;li&gt;The infrastructure, where services deal with specific technological aspects. Example: a notification sending service.&lt;/li&gt;
&lt;li&gt;The application, where services contain coordination logic between other services and are more tied to a specific use-case.
These services are often the ideal place to begin and end a transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;A good service is always stateless. That doesn&amp;rsquo;t mean that a service cannot change the global state of the application
(that is, it may have side effects), but it should never hold a state of its own that could affect its behavior.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;declaration-2&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;Creating a Service with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a service interface, annotated with the &lt;code&gt;@Service&lt;/code&gt; annotation. Business Framework Services are POJOs, there is no mandated super interface.&lt;/li&gt;
&lt;li&gt;Creating a service implementation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-2&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s consider a bank account transfer, which is a service belonging to the domain.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From the domain of a &lt;em&gt;bank account management&lt;/em&gt; perspective, the transfer consists of an amount debited on an
account which is credited on another account.&lt;/li&gt;
&lt;li&gt;The inherent logic of the transfer does not belong to any of the accounts but to a service of the Domain.
It&amp;rsquo;s implementation can be rather simple or complex depending on the rules applying to the process (currency exchange
rate, transfer authorisation between countries, amount on originating account, etc&amp;hellip;).&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;@Service
public interface AccountTransferService {

    public AccountTransferReport transferMoney(Account toBeDebited, Account toBeCredited,
            Amount transferAmount);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Avoid services named like &amp;laquo;AccountManagement&amp;raquo; as they tend to become the place to handle all behaviour for a (sub)domain
instead of clearly specifying the intent and responsibility.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Factories</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/factories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/factories/</guid>
      <description>&lt;p&gt;A factory is a pattern used to &lt;strong&gt;create domain objects&lt;/strong&gt;, checking that provided data is complete and consistent.&lt;/p&gt;

&lt;p&gt;To be created by a factory the domain object must also implements &lt;code&gt;Producible&lt;/code&gt;. This is necessary because all
the domain objects are not producible by a factory. For instance an entity is only be producible by an aggregate
root.&lt;/p&gt;

&lt;p&gt;The types implementing &lt;code&gt;DomainObject&lt;/code&gt; and &lt;code&gt;Producible&lt;/code&gt; are the followings:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AggregateRoot,&lt;/li&gt;
&lt;li&gt;DomainPolicy,&lt;/li&gt;
&lt;li&gt;ValueObject,&lt;/li&gt;
&lt;li&gt;DomainEvent,&lt;/li&gt;
&lt;li&gt;DomainService.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;default-factory&#34;&gt;Default factory&lt;/h1&gt;

&lt;p&gt;The default factory has a single method &lt;code&gt;create&lt;/code&gt; with varargs that will match via reflection the constructor corresponding
to the passed arguments. The created domain object should implement the desired constructors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Customer extends BaseAggregate&amp;lt;Long&amp;gt; {
    private Long id;

    Customer() {
        ...
    }

    Customer(String firstName, String lastName) { // This constructor will be called
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default factory can then be injected and used by invoking its &lt;code&gt;create()&lt;/code&gt; method with arguments unambiguously corresponding
to only one constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
Factory&amp;lt;Customer&amp;gt; factory;

Customer customer = factory.create(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One benefit over the plain constructor approach is that default factories will invoke identity generation (see &lt;a href=&#34;#identity-generation&#34;&gt;below&lt;/a&gt;)
and/or validation automatically after object instantiation. The&lt;/p&gt;

&lt;p&gt;As other factories this method will provide validation on the created object. But it won&amp;rsquo;t survive to refactoring, so be careful using the method (ie. unit test it!).&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;This factory can only be used to create domain objects that implement the &lt;code&gt;Producible&lt;/code&gt; and &lt;code&gt;DomainObject&lt;/code&gt; interfaces. Classes
extending Business framework base classes will already implement those interfaces but annotated POJO, such as policies or
services, must implement them explicitly. As an alternative, you implement the &lt;code&gt;GenericDomainPolicy&lt;/code&gt; and &lt;code&gt;GenericDomainService&lt;/code&gt;
interfaces instead.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;custom-factory&#34;&gt;Custom factory&lt;/h1&gt;

&lt;p&gt;A custom factory is composed of an interface, which is located in the package of the aggregate it constructs, and an
implementation which can be located either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the aggregate package too,&lt;/li&gt;
&lt;li&gt;Or in an infrastructure package if it is dependent upon a specific technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The factory interface has to extend the &lt;code&gt;GenericFactory&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.order;

import org.javatuples.Triplet;
import org.seedstack.business.domain.GenericFactory;

public interface OrderFactory extends GenericFactory&amp;lt;Order&amp;gt; {

    Order createOrder(String customerId, Date checkoutDate, Double price,
            List&amp;lt;Triplet&amp;lt;Integer, Double, Long&amp;gt;&amp;gt; orderItemTriplets);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Order&lt;/code&gt; is the type which is the expected to be returned by all the create methods.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createOrder&lt;/code&gt; method creates an &lt;code&gt;Order&lt;/code&gt; aggregate with the required parameters. Some parameters can be grouped with a tuple like
&lt;code&gt;oderItemTriplets&lt;/code&gt; which represents a list &lt;code&gt;OrderItem&lt;/code&gt; entities belonging to the &lt;code&gt;Order&lt;/code&gt; aggregate (see
&lt;a href=&#34;http://seedstack.org/archives/16.7/docs/business/manual/#tuples&#34;&gt;tuples&lt;/a&gt; for more information on tuple pattern).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The factory implementation must extend the &lt;code&gt;BaseFactory&lt;/code&gt; abstract class and implement its own interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.order;

import org.javatuples.Triplet;
import org.seedstack.business.domain.BaseFactory;
import org.mycompany.myapp.domain.customer.CustomerId;

public class OrderFactoryImpl extends BaseFactory&amp;lt;Order&amp;gt; implements OrderFactory {

    @Override
    public Order createOrder(String customerId) {
        Order o = new Order();

        o.setCustomerId(new CustomerId(customerId));
        o.setCheckoutDate(new Date());

        return o;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the factory encapsulates the logic of creating a minimal but valid &lt;code&gt;Order&lt;/code&gt; aggregate. This order can be further
populated by an assembler or by custom logic.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;When the implementation and its interface share the same package, the &lt;strong&gt;implementation should be in package visibility&lt;/strong&gt;.
It prevents any direct use of the implementation.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;identity-generation&#34;&gt;Identity generation&lt;/h1&gt;

&lt;p&gt;Factories provide methods to create entities with a well defined identity. But sometimes, you want to delegate the identity
creation, for instance to an Oracle sequence. For this use case Seed provides an &lt;strong&gt;identity generation strategies&lt;/strong&gt;.
A generation strategy makes sure a unique identity is provided to any new Entity before it is even persisted.&lt;/p&gt;

&lt;h2 id=&#34;declaration&#34;&gt;Declaration&lt;/h2&gt;

&lt;p&gt;Below is an aggregate using the identity strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.myaggregate;

public class MyAggregate extends BaseAggregateRoot&amp;lt;UUID&amp;gt; {

    @Identity(handler = UUIDHandler.class)
    private UUID id;

    private String name;
    private MyEntity mySubEntity;
    private Set&amp;lt;MyEntity&amp;gt; mySubEntities;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is an Entity using the identity strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.domain.model.myaggregate;

public class MyEntity extends BaseEntity&amp;lt;Long&amp;gt; {

    @Identity(handler = SequenceHandler.class)
    private Long id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;@Identity&lt;/code&gt; annotation is applied on attribute holding the object identity. This annotation takes two arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;: strategy implementation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source&lt;/code&gt;: a String that can be used in a custom handler. For instance, it could provide a SEQUENCE name for DB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only specifying the identity strategy is not enough to effectively generate an identity. An implementation of the strategy
must be configured:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp.domain.model.myaggregate.MyAggregate]
identity.handler-qualifier = simple-UUID

[org.mycompany.myapp.domain.model.myaggregate.MyEntity]
identity.handler-qualifier = oracle-sequence
identity.sequence-name = SEQ_TEST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case we can see that the &lt;code&gt;simple-UUID&lt;/code&gt; implementation will be used for &lt;code&gt;MyAggregate&lt;/code&gt;. Similarly, the &lt;code&gt;oracle-sequence&lt;/code&gt;
implementation will be used for &lt;code&gt;MyEntity&lt;/code&gt; but is further configured with a sequence name.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;The chosen identity strategy is applied:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Automatically, on methods annotated with the &lt;code&gt;@Create&lt;/code&gt; annotation. They are intercepted to apply the identity strategy
on their return value.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class MyAggregateFactoryDefault extends BaseFactory&amp;lt;MyAggregate&amp;gt;
        implements MyAggregateFactory {

    @Create
    @Override
    public MyAggregate createMyAggregate(String name) {
        MyAggregate myAggregate = new MyAggregate();
        myAggregate.setName(name);

        MyEntity myEntity = createMyEntity();
        myAggregate.setMyEntity(myEntity);

        return myAggregate;
    }

    @Create
    MyEntity createMyEntity() {
        return new MyEntity();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Manually, by injecting the &lt;code&gt;IdentityService&lt;/code&gt; service and invoking its &lt;code&gt;identify()&lt;/code&gt; method with the entity to generate
an identity for as argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class MyAggregateFactoryDefault extends BaseFactory&amp;lt;MyAggregate&amp;gt;
        implements MyAggregateFactory {

    @Inject
    IdentityService identityService;

    @Override
    public MyAggregate createMyAggregate(String name) {
        MyAggregate myAggregate = new MyAggregate();
        identityService.identify(myAggregate);
        myAggregate.setName(name);

        MyEntity myEntity = new MyEntity();
        identityService.identify(myEntity);
        myAggregate.setMyEntity(myEntity);

        return myAggregate;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that identity generation doesn&amp;rsquo;t walk the object graph to generate identities for eventual sub-entities. You must
trigger identity generation (automatically or manually) separately on each entity.&lt;/p&gt;

&lt;div class=&#34;callout callout-tips&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
                &lt;i class=&#34;fa fa-lightbulb-o icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;If all methods of a factory delegate identity generation to Seed, a &lt;code&gt;@Create&lt;/code&gt; annotation can be applied directly at the
class or interface level.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;custom-identity-handler&#34;&gt;Custom identity handler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;img/manage-entity-spi.svg&#34; alt=&#34;identity-seed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Two different options are available to define custom identity handlers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/manage-entity-usage.png&#34; alt=&#34;identity-seed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Below is an example of a basic Timestamp id generation strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.infrastructure.domain;

import org.seedstack.business.domain.BaseEntity;
import org.seedstack.business.domain.identity.IdentityHandler;

@Named(&amp;quot;timestamp-id&amp;quot;)
public class TimestampIdentityHandler implements IdentityHandler&amp;lt;BaseEntity&amp;lt;Long&amp;gt;, Long&amp;gt; {

    @Override
    public Long handle(BaseEntity&amp;lt;Long&amp;gt; entity, Map&amp;lt;String, String&amp;gt; entityConfig) {
        return new Date().getTime();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;provided-identity-strategies&#34;&gt;Provided identity strategies&lt;/h2&gt;

&lt;h3 id=&#34;sequencehandler&#34;&gt;SequenceHandler&lt;/h3&gt;

&lt;p&gt;Handles sequence generated ID. Two implementations are provided:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OracleSequenceHandler&lt;/code&gt;: Get next oracle sequence value for new entity id. The following properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = oracle-sequence
identity.sequence-name = your_sequence_name
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InMemorySequenceHandler&lt;/code&gt;: To be used &lt;strong&gt;ONLY&lt;/strong&gt; for testing (preserves behaviour without a database). The following
properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = inmemory-sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uuidhandler&#34;&gt;UUIDHandler&lt;/h3&gt;

&lt;p&gt;Use for handling UUID generated ID. One implementation is provided:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SimpleUUIDHandler&lt;/code&gt;: Get new random UUID from java.util.UUID.randomUUID(). Need one property using entity props
configuration:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[org.mycompany.myapp...YourEntity]
identity.handler-qualifier = simple-UUID
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Finders</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/finders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/finders/</guid>
      <description>&lt;p&gt;The role of a finder is to query the persistence layer or any data source to obtain objects specific to an interface of
the application. It only does &lt;strong&gt;read-only&lt;/strong&gt; operations and is NOT meant to replace the repository as it doesn&amp;rsquo;t produce
domain objects but interface-specific objects like REST representations.&lt;/p&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;A finder shouldn&amp;rsquo;t generally delegate its data retrieval to the domain repository. Instead it should directly issue the most efficient query against the persistence layer and construct DTO objects, completely bypassing the domain. Consider the following implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You should write as many finders as required by your application interfaces.&lt;/li&gt;
&lt;li&gt;You can query a model completely different from your domain model and optimized for reading purposes (i.e. a read model) or not model at all.&lt;/li&gt;
&lt;li&gt;You can rely on a completely different technology than the domain persistence, like an high-performance index.&lt;/li&gt;
&lt;/ul&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;callout callout-tips&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
                &lt;i class=&#34;fa fa-lightbulb-o icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;Don&amp;rsquo;t create finders needlessly: if your data retrieval needs are simple enough to not require a finder, just use the domain repositories directly in your interface and transform the retrieved domain objects to DTO with assemblers.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Creating a Finder with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a finder interface,&lt;/li&gt;
&lt;li&gt;Creating a finder implementation, located in the infrastructure as it depends upon a persistence technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Business Framework Finders are POJOs, there is no mandated interface. Just annotate your finder interface with the
&lt;code&gt;@Finder&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h1 id=&#34;interface&#34;&gt;Interface&lt;/h1&gt;

&lt;p&gt;Create the interface for your finder. A finder is annotated with &lt;code&gt;@Finder&lt;/code&gt; and is declared as read only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Finder
public interface CustomerFinder {

    List&amp;lt;CustomerRepresentation&amp;gt; findAllCustomers();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;p&gt;In the infrastructure layer, provide the implementation (here with JPA):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CustomerJpaFinder implements CustomerFinder {

    @Inject
    private FluentAssembler assembler;

    @Override
    public List&amp;lt;CustomerRepresentation&amp;gt; findAllCustomer() {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&amp;lt;Customer&amp;gt; q = cb.createQuery(Customer.class);
        q.select(q.from(Customer.class));

        return fluentAssembler
                   .assemble(entityManager.createQuery(q).getResultList())
                   .to(CustomerRepresentation.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Policies</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/policies/</guid>
      <description>&lt;p&gt;A policy is a variant of the Strategy pattern to encapsulate one or more business rules.&lt;/p&gt;

&lt;h1 id=&#34;definition&#34;&gt;Definition&lt;/h1&gt;

&lt;p&gt;Creating a Policy with the Business Framework, consists in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a policy interface in the domain,&lt;/li&gt;
&lt;li&gt;Creating a policy implementation, located either in the domain or in the infrastructure if it depends upon any
specific technology.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Business Framework Policies are POJOs, there is no mandated interface. Just annotate your policy interface with the
&lt;code&gt;@DomainPolicy&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;To use a policy, simply inject it in your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
MyPolicy myPolicy;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s consider a bonus policy for car sellers according to the sales they&amp;rsquo;ve done.
This policy could allow the sellers - and their manager - to know what the amount of their bonus is at a given time in
the current month.&lt;/p&gt;

&lt;h2 id=&#34;bonuspolicy-interface&#34;&gt;BonusPolicy interface&lt;/h2&gt;

&lt;p&gt;In &lt;code&gt;org.mycompany.myapp.policy&lt;/code&gt; package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.policy;

import org.mycompany.myapp.domain.model.carsold.CarSold;
import org.mycompany.myapp.domain.shared.vo.Price;
import org.seedstack.business.domain.DomainPolicy;

import java.util.List;

@DomainPolicy
public interface BonusPolicy {
	Price computeBonus(List&amp;lt;CarSold&amp;gt; carSolds);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bonuspolicy-implementation&#34;&gt;BonusPolicy implementation&lt;/h2&gt;

&lt;p&gt;Below is an implementation example.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;org.mycompany.myapp.policy.internal&lt;/code&gt; package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.policy.internal;

import ...

public class BonusPolicyInternal implements BonusPolicy{

    @Override
	public Price computeBonus(List&amp;lt;CarSold&amp;gt; soldCarsList) {
        ...
		return finalBonus;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bonuspolicy-usage&#34;&gt;BonusPolicy usage&lt;/h2&gt;

&lt;p&gt;Wherever the policy is used to compute the bonus of a particular employee, just retrieve the cars sold by this employee
(through the sold cars repository) and call the policy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Interface&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.application.service;

import org.mycompany.myapp.domain.model.employee.Employee;
import org.seedstack.business.Service;

@Service
public interface SalesBonusService {
    double calculateCurrentBonusFor(Employee employee);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package org.mycompany.myapp.application.service.internal;

import ...

public class SalesBonusServiceInternal implements SalesBonusService {
	
	@Inject
	CarSoldRepository carSoldRepository;
	
	@Inject
	CarForSaleRepository carForSaleRepository;
	
	@Inject
	BonusPolicy bonusPolicy;
	
	@Override
	public double calculateCurrentBonusFor(Employee employee) {
		List&amp;lt;CarSold&amp;gt; findByEmployee = carSoldRepository
             .findByEmployee(employee.getEntityId());
		Price bonus = bonusPolicy.computeBonus(findByEmployee);
		return bonus.getPriceValue();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, one can just inject the service and compute a bonus whenever an &lt;code&gt;Employee&lt;/code&gt; entity is at reach (eg. while building
an employee profile page).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Repositories</title>
      <link>http://seedstack.org/archives/16.7/docs/business/manual/repositories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://seedstack.org/archives/16.7/docs/business/manual/repositories/</guid>
      <description>&lt;p&gt;A repository is a pattern used to store and retrieve Aggregates from persistence with a &lt;strong&gt;simple and global interface&lt;/strong&gt;,
providing the illusion of an in-memory collection. A repository manipulates a whole aggregate through its aggregate
root and ensures that it is persisted and retrieved in a coherent manner.&lt;/p&gt;

&lt;h1 id=&#34;default-repository&#34;&gt;Default repository&lt;/h1&gt;

&lt;p&gt;The Business Framework provides a default repository that can perform CRUD actions on an aggregate.
It can be injected with the &lt;code&gt;Repository&lt;/code&gt; interface and a qualifier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject @Jpa
private Repository&amp;lt;Customer, String&amp;gt; customerRepo;

...
Customer customer = customerRepo.load(customerId);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;By default, you have to explicitly specify the qualifier.
But if you have only one persistence and one default repository, you can configure the one to use.
The default repository can be configured for all the application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.example.*]
default-repository=org.seedstack.jpa.Jpa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also override it for a specific aggregate root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[org.example.domain.customer.Customer]
default-repository=another-qualifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;default.repository.qualifier&lt;/code&gt; property expects a qualifier annotation class or a string when the qualifier use &lt;code&gt;@Named(&amp;quot;another-qualifer&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;custom-repository&#34;&gt;Custom repository&lt;/h1&gt;

&lt;p&gt;The default CRUD repository is interesting to start quickly and might be enough for some use cases. But it is possible to
add your own repositories, in order to extend the CRUD behavior with your domain
requirements.&lt;/p&gt;

&lt;p&gt;First create a repository interface extending &lt;code&gt;GenericRepository&lt;/code&gt;. This interface is usually located in the aggregate package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.seedstack.business.domain.Repository;

public interface OrderRepository extends GenericRepository&amp;lt;Order, Long&amp;gt; {

     Order findOrderByCategory(String categoryId)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;callout callout-info&#34;&gt;
    &lt;div style=&#34;display:table; width: 100%&#34;&gt;
        &lt;div style=&#34;display:table-cell; width: 50px; vertical-align: middle;&#34;&gt;
            
            
                &lt;i class=&#34;fa fa-info-circle icon-2x&#34; style=&#34;line-height: 30px;&#34;&gt;&lt;/i&gt;
            
            
            
        &lt;/div&gt;
        &lt;div style=&#34;display:table-cell; vertical-align: middle;&#34;&gt;
            &lt;p&gt;It is possible not to use the &lt;code&gt;GenericRepository&lt;/code&gt; interface and instead annotate the class with the &lt;code&gt;@DomainRepository&lt;/code&gt; annotation.
But you won&amp;rsquo;t be able to use the framework&amp;rsquo;s helpers like the assembler DSL &lt;code&gt;fromRepository()&lt;/code&gt; method.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then add an implementation in the infrastructure layer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class OrderJpaRepository extends BaseJpaRepository&amp;lt;Order, Long&amp;gt; implements OrderRepository {

    @Override
    public Order findOrderByCategory(String categoryId){ ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;An explicit repository can be injected like a default one (with the &lt;code&gt;Repository&lt;/code&gt; interface):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private Repository&amp;lt;Order, Long&amp;gt; repository;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or with its own interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Inject
private OrderRepository repository;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>